<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Norman | 技术博客</title>
  <icon>https://www.gravatar.com/avatar/e6a650df8c6a02ff6d0ee8d2c77fadea</icon>
  <subtitle>荟萃，探索，蓄力，拼搏</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-06-22T11:54:08.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Norman</name>
    <email>hulong717@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>一次因TCP挥手导致的HTTP请求异常</title>
    <link href="http://yoursite.com/2019/06/22/%E4%B8%80%E6%AC%A1%E5%9B%A0TCP%E6%8C%A5%E6%89%8B%E5%AF%BC%E8%87%B4%E7%9A%84HTTP%E8%AF%B7%E6%B1%82%E5%BC%82%E5%B8%B8.html"/>
    <id>http://yoursite.com/2019/06/22/一次因TCP挥手导致的HTTP请求异常.html</id>
    <published>2019-06-22T11:39:57.000Z</published>
    <updated>2019-06-22T11:54:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>线上业务需要http需要和多个上游交互，使用httpclient包装的请求类，通过日志扫描系统的异常（grep），发现到达某个上游的请求，每天都会有几次异常，导致请求失败，同时抛出 <code>NoHTTPResponseException</code>！<br>通过Apache官方文档，目测是因为服务端过于拥挤导致连接未响应，直接被丢弃了，后经询问，服务器此时的QPS并不高</p><p>因为是服务器之前频繁的通信，所以最好使用长连接，http层加入keepalive机制。我们把httpclient的keepalive的时间设置成30秒，不过后面依然会出现，必定是另有原因。</p><a id="more"></a><p>通过Linux的tcpdump，我们抓取指定上游的tcp报文，当再次出现异常时，我们通过时间从dump的日志中有了实质性的发现</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 假定上游服务器地址: 11.22.33.44</span><br><span class="line"><span class="meta">#</span> dump本机和指定主机交互的所有流量</span><br><span class="line">nohup tcpdump -i eth0 host 11.22.33.44  -nnn  &amp;</span><br></pre></td></tr></table></figure><p>dump下来的日志，格式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">11:29:43.939417 IP 11.22.33.44.8211 &gt; 172.19.0.1.59024: Flags [P.], seq 2506:2511, ack 4122, win 78, length 5</span><br><span class="line">11:29:43.939424 IP 172.19.0.1.59024 &gt; 11.22.33.44.8211: Flags [.], ack 2511, win 312, length 0</span><br><span class="line">11:29:43.941362 IP 11.22.33.44.8211 &gt; 172.19.0.1.59046: Flags [.], ack 411, win 60, length 0</span><br><span class="line">11:29:44.891319 IP 11.22.33.44.8211 &gt; 172.19.0.1.59046: Flags [P.], seq 1:247, ack 411, win 60, length 246</span><br><span class="line">11:29:44.891384 IP 172.19.0.1.59046 &gt; 11.22.33.44.8211: Flags [.], ack 247, win 237, length 0</span><br><span class="line">11:29:44.891322 IP 11.22.33.44.8211 &gt; 172.19.0.1.59046: Flags [P.], seq 247:252, ack 411, win 60, length 5</span><br><span class="line">11:29:44.891396 IP 172.19.0.1.59046 &gt; 11.22.33.44.8211: Flags [.], ack 252, win 237, length 0</span><br><span class="line">11:29:50.007828 IP 172.19.0.1.59046 &gt; 11.22.33.44.8211: Flags [P.], seq 411:824, ack 252, win 237, length 413</span><br><span class="line">11:29:50.030832 IP 11.22.33.44.8211 &gt; 172.19.0.1.59046: Flags [.], ack 824, win 62, length 0</span><br></pre></td></tr></table></figure></p><blockquote><p>题外话：日志中发现，我们有很多端口和 8211 进行交互，也就是意味着有多个tcp连接</p></blockquote><p>通过监控，我们发现异常出现在11:43:53.21出现了问题，在这个时间点附近的日志如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">11:43:38.215638 IP 11.22.33.44.8211 &gt; 172.19.0.1.59602: Flags [P.], seq 749:754, ack 1240, win 64, length 5</span><br><span class="line">11:43:38.215669 IP 172.19.0.1.59602 &gt; 11.22.33.44.8211: Flags [.], ack 754, win 254, length 0</span><br><span class="line">11:43:52.898135 IP 11.22.33.44.8211 &gt; 172.19.0.1.59614: Flags [F.], seq 252, ack 414, win 60, length 0</span><br><span class="line">11:43:52.936947 IP 172.19.0.1.59614 &gt; 11.22.33.44.8211: Flags [.], ack 253, win 237, length 0</span><br><span class="line">11:43:53.212664 IP 172.19.0.1.59602 &gt; 11.22.33.44.8211: Flags [P.], seq 1240:1650, ack 754, win 254, length 410</span><br><span class="line">11:43:53.215228 IP 11.22.33.44.8211 &gt; 172.19.0.1.59602: Flags [F.], seq 754, ack 1240, win 64, length 0</span><br><span class="line">11:43:53.215294 IP 172.19.0.1.59602 &gt; 11.22.33.44.8211: Flags [F.], seq 1650, ack 755, win 254, length 0</span><br><span class="line">11:43:53.235410 IP 11.22.33.44.8211 &gt; 172.19.0.1.59602: Flags [R], seq 1246386853, win 0, length 0</span><br><span class="line">11:43:53.238071 IP 11.22.33.44.8211 &gt; 172.19.0.1.59602: Flags [R], seq 1246386854, win 0, length 0</span><br><span class="line">11:43:54.747270 IP 172.19.0.1.59614 &gt; 11.22.33.44.8211: Flags [F.], seq 414, ack 253, win 237, length 0</span><br><span class="line">11:43:54.747378 IP 172.19.0.1.59622 &gt; 11.22.33.44.8211: Flags [S], seq 2657401300, win 29200, options [mss 1460,sackOK,TS val 3040913527 ecr 0,nop,wscale 7], length 0</span><br></pre></td></tr></table></figure></p><p>基本可以确定是本地端口 <strong>59602</strong> 和远程 <strong>8211</strong> 建立的这条tcp连接<br>在日志中通过端口号 59602 把所有的tcpdump信息全部取出，得到：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">11:43:20.822142 IP 172.19.0.1.59602 &gt; 11.22.33.44.8211: Flags [S], seq 921702317, win 29200, options [mss 1460,sackOK,TS val 3040905046 ecr 0,nop,wscale 7], length 0</span><br><span class="line">11:43:20.844940 IP 11.22.33.44.8211 &gt; 172.19.0.1.59602: Flags [S.], seq 1246386099, ack 921702318, win 29200, options [mss 1444,nop,nop,sackOK,nop,wscale 9], length 0</span><br><span class="line">11:43:20.844966 IP 172.19.0.1.59602 &gt; 11.22.33.44.8211: Flags [.], ack 1, win 229, length 0</span><br><span class="line">11:43:20.845028 IP 172.19.0.1.59602 &gt; 11.22.33.44.8211: Flags [P.], seq 1:414, ack 1, win 229, length 413</span><br><span class="line">11:43:20.867813 IP 11.22.33.44.8211 &gt; 172.19.0.1.59602: Flags [.], ack 414, win 60, length 0</span><br><span class="line">11:43:23.053412 IP 11.22.33.44.8211 &gt; 172.19.0.1.59602: Flags [P.], seq 1:247, ack 414, win 60, length 246</span><br><span class="line">11:43:23.053461 IP 172.19.0.1.59602 &gt; 11.22.33.44.8211: Flags [.], ack 247, win 237, length 0</span><br><span class="line">11:43:23.053415 IP 11.22.33.44.8211 &gt; 172.19.0.1.59602: Flags [P.], seq 247:252, ack 414, win 60, length 5</span><br><span class="line">11:43:23.053473 IP 172.19.0.1.59602 &gt; 11.22.33.44.8211: Flags [.], ack 252, win 237, length 0</span><br><span class="line">11:43:23.364308 IP 172.19.0.1.59602 &gt; 11.22.33.44.8211: Flags [P.], seq 414:827, ack 252, win 237, length 413</span><br><span class="line">11:43:23.387087 IP 11.22.33.44.8211 &gt; 172.19.0.1.59602: Flags [.], ack 827, win 62, length 0</span><br><span class="line">11:43:23.873071 IP 11.22.33.44.8211 &gt; 172.19.0.1.59602: Flags [P.], seq 252:498, ack 827, win 62, length 246</span><br><span class="line">11:43:23.873112 IP 172.19.0.1.59602 &gt; 11.22.33.44.8211: Flags [.], ack 498, win 245, length 0</span><br><span class="line">11:43:23.873074 IP 11.22.33.44.8211 &gt; 172.19.0.1.59602: Flags [P.], seq 498:503, ack 827, win 62, length 5</span><br><span class="line">11:43:23.873122 IP 172.19.0.1.59602 &gt; 11.22.33.44.8211: Flags [.], ack 503, win 245, length 0</span><br><span class="line">11:43:36.883015 IP 172.19.0.1.59602 &gt; 11.22.33.44.8211: Flags [P.], seq 827:1240, ack 503, win 245, length 413</span><br><span class="line">11:43:36.905781 IP 11.22.33.44.8211 &gt; 172.19.0.1.59602: Flags [.], ack 1240, win 64, length 0</span><br><span class="line">11:43:38.215636 IP 11.22.33.44.8211 &gt; 172.19.0.1.59602: Flags [P.], seq 503:749, ack 1240, win 64, length 246</span><br><span class="line">11:43:38.215662 IP 172.19.0.1.59602 &gt; 11.22.33.44.8211: Flags [.], ack 749, win 254, length 0</span><br><span class="line">11:43:38.215638 IP 11.22.33.44.8211 &gt; 172.19.0.1.59602: Flags [P.], seq 749:754, ack 1240, win 64, length 5</span><br><span class="line">11:43:38.215669 IP 172.19.0.1.59602 &gt; 11.22.33.44.8211: Flags [.], ack 754, win 254, length 0</span><br><span class="line">11:43:53.212664 IP 172.19.0.1.59602 &gt; 11.22.33.44.8211: Flags [P.], seq 1240:1650, ack 754, win 254, length 410</span><br><span class="line">11:43:53.215228 IP 11.22.33.44.8211 &gt; 172.19.0.1.59602: Flags [F.], seq 754, ack 1240, win 64, length 0</span><br><span class="line">11:43:53.215294 IP 172.19.0.1.59602 &gt; 11.22.33.44.8211: Flags [F.], seq 1650, ack 755, win 254, length 0</span><br><span class="line">11:43:53.235410 IP 11.22.33.44.8211 &gt; 172.19.0.1.59602: Flags [R], seq 1246386853, win 0, length 0</span><br><span class="line">11:43:53.238071 IP 11.22.33.44.8211 &gt; 172.19.0.1.59602: Flags [R], seq 1246386854, win 0, length 0</span><br></pre></td></tr></table></figure></p><p>文字可能不太直观，同时ip和端口不太适合阅读，所以替换成client和server，截了张图：<br><img src="https://raw.githubusercontent.com/hulog/hulog.github.io/blog/source/images/post/tcpdump_format.jpg" alt="tcpdumpFormatDisplay"></p><p>为了不迷路，简单普及下tcpdump中flags的几个标志的意义：</p><ol><li><strong>S</strong>：SYN标志位=1的报文 用于握手建立连接时</li><li><strong>P</strong>：PSH标志位=1的报文 用于发送业务数据时</li><li><strong>F</strong>：FIN标志位=1的报文 用于挥手断开连接时</li><li><strong>R</strong>：RST标志位=1的报文 用于重置异常连接时</li><li><strong>.</strong>：ACK标志位=1的报文 用于确认收到消息时</li></ol><p>状态描述：</p><ul><li>第28行，第三次数据交换结束，client向server发送ack报文，本次http交互结束</li><li>第31行，client第四次发起数据请求</li><li>第32行，服务器发回一个FIN报文，表示要中断TCP连接</li></ul><p>问题：</p><ol><li>前3次数据交换没有问题，为什么在第4次发送数据后，居然立马收到FIN报文？</li><li>28行和32行，时间差刚好15s，这个数字不像是随机的，应该是什么机制中设置的吧？</li></ol><p>释疑：</p><ol><li>FIN包的ack是1240，这是client上一交互环节发送的最后一个报文，应该是没有收到31行报文，应该是client和server几乎同时发送了PSH和FIN报文，client以为TCP没断就放心发送报文了！</li><li>经核实，上游使用阿里云SLB负载均衡，长连接默认保持15秒，闲置15秒无数据交互就会主动断掉！同时，一般的服务器或反向代理也会有这个机制。同时也解释了为什么之前已经设置了30s的超时时间，依然会出现这种异常了，因为服务器说：<code>15秒 &lt; 30秒，老弟，我先断了喂 拜拜~</code></li></ol><p>那么，我们需要对httputil进行改造，使其能够支持失败请求重试，Apache的httpclient已经支持了，不过默认不重试，加上就好了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">httpClient = HttpClients.custom()</span><br><span class="line">        .setKeepAliveStrategy((response, context) -&gt; DEFAULT_KEEP_ALIVE_TIME)</span><br><span class="line">        .setRetryHandler(DefaultHttpRequestRetryHandler.INSTANCE)</span><br><span class="line">        .setConnectionManager(cm)</span><br><span class="line">        .build();</span><br></pre></td></tr></table></figure><p>如需定制化重试机制，实现HttpRequestRetryHandler即可，<a href="http://hc.apache.org/httpcomponents-client-4.5.x/tutorial/html/fundamentals.html#d5e316" target="_blank" rel="noopener">官网示例连接</a></p><p>在最后，热心的同事提到，如果网络时延15ms，15秒的keepalive timeout，则这种异常出现的几率是 <code>15 ÷ 15000 = 1‰</code>，也不知道对不对，统计了下，好像差不多，哈哈</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;线上业务需要http需要和多个上游交互，使用httpclient包装的请求类，通过日志扫描系统的异常（grep），发现到达某个上游的请求，每天都会有几次异常，导致请求失败，同时抛出 &lt;code&gt;NoHTTPResponseException&lt;/code&gt;！&lt;br&gt;通过Apache官方文档，目测是因为服务端过于拥挤导致连接未响应，直接被丢弃了，后经询问，服务器此时的QPS并不高&lt;/p&gt;
&lt;p&gt;因为是服务器之前频繁的通信，所以最好使用长连接，http层加入keepalive机制。我们把httpclient的keepalive的时间设置成30秒，不过后面依然会出现，必定是另有原因。&lt;/p&gt;
    
    </summary>
    
      <category term="http" scheme="http://yoursite.com/categories/http/"/>
    
    
      <category term="Socket" scheme="http://yoursite.com/tags/Socket/"/>
    
      <category term="tcp" scheme="http://yoursite.com/tags/tcp/"/>
    
      <category term="tcpdump" scheme="http://yoursite.com/tags/tcpdump/"/>
    
      <category term="http" scheme="http://yoursite.com/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>EleasticSearch 线上大索引按日期分割</title>
    <link href="http://yoursite.com/2019/04/23/es-index-reindex.html"/>
    <id>http://yoursite.com/2019/04/23/es-index-reindex.html</id>
    <published>2019-04-23T08:03:54.000Z</published>
    <updated>2019-06-22T11:37:16.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h2><p>由于项目初期设计问题，采集到es的业务日志只使用了一个索引(index)，随着线上日志量的增长，es很快飙升到磁盘警戒线，线上找了一圈，很多文章版本都比较老旧，最终直接啃官方文档得出，没有copy别人博客，如果你中途不走神，本文总共15min。version 适用于es 6.0+</p><a id="more"></a><p>本文前提保障：</p><ol><li>文档中有时间字段，方便按日期切割</li><li>index的<code>mapping</code>配置中，<code>_source</code>需为 <code>true</code>（默认），以保证es存入了源文档，而不仅仅是docId<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -XGET "localhost:9200/your_index_name/_mapping"</span><br><span class="line"><span class="meta">#</span> 如果没有显示 _source, 代表"_source": false</span><br></pre></td></tr></table></figure></li></ol><h2 id="2-删文档（不建议）"><a href="#2-删文档（不建议）" class="headerlink" title="2. 删文档（不建议）"></a>2. 删文档（不建议）</h2><p>这第一个想到的方法，将最老旧的日志删掉，如只保留近3个月的，采用 <code>delete_by_query</code> 接口<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST "localhost:9200/twitter/_delete_by_query" -H 'Content-Type: application/json' -d'</span><br><span class="line">&#123;</span><br><span class="line">  "query": &#123;</span><br><span class="line">    "range" : &#123;</span><br><span class="line">        "day" : &#123;</span><br><span class="line">           "lt" : "2018-12-01"</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">'</span><br></pre></td></tr></table></figure></p><p>但是，es的delete，并不是真正的物理删，磁盘使用率(utilization)并不会下降。删除的文档仅仅被标记，es将文档存入一个个segment file中，其file数量随着文档的写入不断增加，es因此会有合并segment file的操作，将多个小的segment合并成一个大的segment file，当segment合并的时候，标记的文档才会真正的物理删除。</p><p>这种方案，只适合在 <strong>项目早期、文档量少、且机器负载不高</strong> 情况下进行，因为批量读写会导致cpu utilization的飙升，造成系统负载加重，可以在晚上业务量不高的时候进行</p><h2 id="3-磁盘扩容-短期有效"><a href="#3-磁盘扩容-短期有效" class="headerlink" title="3. 磁盘扩容 (短期有效)"></a>3. 磁盘扩容 (短期有效)</h2><p>那如果标记删除不能立即解决问题，那就对磁盘扩容吧！1T 到 2T，2T 到 4T，由于升级磁盘需要重启机器，所以，如何做到优雅滚动关停es至关重要！</p><h3 id="3-1-停止es集群服务"><a href="#3-1-停止es集群服务" class="headerlink" title="3.1 停止es集群服务"></a>3.1 停止es集群服务</h3><p>常见就是<code>ps</code>看一下es的进程，然后<code>kill</code>，先等一下！在此之前，需对集群进行配置，方便更加快速的服务重启</p><h4 id="3-1-1-停止分片分配"><a href="#3-1-1-停止分片分配" class="headerlink" title="3.1.1 停止分片分配"></a>3.1.1 停止分片分配</h4><p>由于es中的index是分布式存储，所以一个index分成了多个shard，分布在各个节点node上，每个shard都可以单独提供服务，同时每个shard可以配置多个副本(replicas)，保证集群的高可用，提高了查询效率。同时，es在管理这些分片时，有一套自有的均衡算法，保证shard均匀分散在各个node上，同时保证每个shard和其对应的replica不在同一node上。正是这种机制，使得当node离开和重新加入的时候，分片的分配会copy文件，会造成大量的io，因为node重启很快就回来，所以暂时关掉自动分片分配，详情参见另一篇文章，介绍集群重启步骤。这里选择直接停止分配</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">curl -X PUT "localhost:9200/_cluster/settings" -H 'Content-Type: application/json' -d'</span><br><span class="line">&#123;</span><br><span class="line">  "persistent": &#123;</span><br><span class="line">    "cluster.routing.allocation.enable": "none"</span><br><span class="line">  &#125;</span><br><span class="line">&#125;'</span><br></pre></td></tr></table></figure><p>这样，在node停掉的时候，不会出现分片分配重新均衡了。</p><h4 id="3-1-2-挂载新盘"><a href="#3-1-2-挂载新盘" class="headerlink" title="3.1.2 挂载新盘"></a>3.1.2 挂载新盘</h4><p>由于机器是云上资源，因此按照各个云上的扩容文档操作即可，无论是自有机房还是云上机器，无非是下面几个步骤：</p><ol start="0"><li><code>reboot</code>重启</li><li><code>df -h</code> 看一下现在的挂载点（如/dev/vdb）和 挂载路径(如/data/es/)</li><li><code>fdisk -l</code> 可以进一步确认盘的信息</li><li><code>fdisk /dev/vdb</code>，对新盘进行重新挂载，命令中可能涉及到的选项，不分区的话，大部分按回车默认选项：d n p 1 wq</li><li><p>其他操作 如<code>e2fsck -f /dev/vdb</code>,<code>resize2fs /dev/vdb</code></p></li><li><p><code>mount /dev/vdb /data</code> 重新挂载即可</p></li></ol><h4 id="3-1-3-恢复分配分配"><a href="#3-1-3-恢复分配分配" class="headerlink" title="3.1.3 恢复分配分配"></a>3.1.3 恢复分配分配</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">curl -X PUT "localhost:9200/_cluster/settings" -H 'Content-Type: application/json' -d'</span><br><span class="line">&#123;</span><br><span class="line">  "transient": &#123;</span><br><span class="line">    "cluster.routing.allocation.enable": "all"</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">'</span><br></pre></td></tr></table></figure><p>这一步，会有部分io，等到recovery结束，集群恢复正常。如果有 <strong>Unassigned</strong> 状态的shard，需要手动执行分片分配，对应的命令<code>reroute</code>，这个不难，正常情况下，几乎不会出现 <strong>Unassigned</strong> 的shard。<br>执行完上述操作，磁盘体积翻倍。在短期内，可以保证服务正常。</p><h2 id="4-索引拆分-最佳实践"><a href="#4-索引拆分-最佳实践" class="headerlink" title="4. 索引拆分(最佳实践)"></a>4. 索引拆分(最佳实践)</h2><p>无论标记删除，还是磁盘扩容，都没有真正的解决索引过大的问题，随着文档数的增加，索引势必会变得更大。针对大索引，标记删除以及扩容后分片恢复的操作时间，也会大幅增加，可能会从几小时到一两天。上述方法不可行！</p><p>因为es对index的删除是物理删除，是立即的，既然不能直接删除原索引，得想办法把大索引拆成小索引，然后再删除老旧的。那么es有么有这种api，将大的索引按照某种条件(按天、按月)进行拆分呢？为此，我找了很多博客，最后发现，很多博客里介绍的api都很老旧，还是官网的文档最实在，文档是英文，不过理解起来并不复杂。墙裂推荐看官方文档。为此，我调研了这些api：<code>_rollover</code>，<code>alias</code>，<code>template</code>，<code>reindex</code>，大家可以有针对的深入学习这几个api，细节这里就不讲了，先看我怎么用的吧~</p><h3 id="4-1-错误尝试"><a href="#4-1-错误尝试" class="headerlink" title="4.1. 错误尝试"></a>4.1. 错误尝试</h3><p><code>_rollover</code> 当看到这个api时，我以为找到了最接近需求的api，这个api介绍如下</p><blockquote><p>The rollover index API rolls an alias over to a new index when the existing index is considered to be too large or too old.</p></blockquote><p>显然被 <strong>too large</strong> 和 <strong>too old</strong> 吸引了。。。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">curl -X PUT "localhost:9200/logs-000001" -H 'Content-Type: application/json' -d'</span><br><span class="line">&#123;</span><br><span class="line">  "aliases": &#123;</span><br><span class="line">    "logs_write": &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">'</span><br><span class="line"><span class="meta">#</span> Add &gt; 1000 documents to logs-000001</span><br><span class="line">curl -X POST "localhost:9200/logs_write/_rollover" -H 'Content-Type: application/json' -d'</span><br><span class="line">&#123;</span><br><span class="line">  "conditions": &#123;</span><br><span class="line">    "max_age":   "7d", #当文档创建时间大于7天</span><br><span class="line">    "max_docs":  1000, #当文档数量超过上限1000</span><br><span class="line">    "max_size":  "5gb" #当索引大小超过5GB</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">'</span><br></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>先给 <em>index</em> 建一个别名 <em>alias</em>，再 <code>rollover</code>，当执行时，满足任一个条件即可创建新索引，同时别名 <em>alias</em> 指向新的，除此之外，<code>_rollover</code>还可以按日期生成新索引</p><p><strong>问题：</strong></p><ol><li>拆分只在api执行时生效，后面不会自动拆分，如果按天索引，则必须每天定时执行，增加维护成本，如果定时任务失败…</li><li>当别名滚向新的索引后，旧索引不能通过 <em>alias</em> 再访问</li><li>并没有将历史的索引按天生成，只是在此api执行后，新文档才会进新index</li></ol><h3 id="4-2-最佳实践"><a href="#4-2-最佳实践" class="headerlink" title="4.2 最佳实践"></a>4.2 最佳实践</h3><p>假设原索引name <strong>knight-log</strong>，当前月份 <strong>2019-02</strong></p><p><img src="https://github.com/hulog/hulog.github.io/blob/blog/source/images/post/es-index-reindex.jpg?raw=true" alt="es-索引拆分思路"></p><p><strong>思路：</strong></p><ol><li>创建别名alias：<strong>alias-knight-log</strong></li><li>为旧的 <em>knight-log</em> 关联别名 <strong>alias-knight-log</strong></li><li>创建索引模板template: <strong>template-knight-log</strong>，该模板匹配所有 <code>knight-log.*</code> 索引,在模板中定义settings和mappings，以及自动关联别名 alias-knight-log</li></ol><p>此外，将项目中读写es的操作分别设置：</p><ol><li>读 <em>alias-knight-log</em>，可以查询所有关联索引</li><li>写 <em>knight-log.2019-02</em>，在原索引后append月份即可！调用Java api进行索引时，接口规定每条文档需要指定index name，因此将原来的 <em>name</em> 变为 <em>name + current_month</em> 即可，其他语言同理！</li></ol><p>更新业务代码，重新上线后，新文档会进入到形如 <strong>knight-log.2019-02</strong> 的索引中，原 <em>knight-log</em> 将不会有写请求，读请求也经过别名 <em>alias-knight-log</em> 代理了</p><p>经过上述步骤，旧的index只读不写，写请求全部进入 <strong>knight-log.2019-02</strong> 的索引中，保障了这一点，我们就可以对 <em>knight-log</em> 按时间粒度以大化小，逐个删除了！</p><p>Sad，没有这种直接的api，不过，不起眼的<code>reindex</code>却承担起这个重任，一开始我觉得跟这个api应该没有关系，不仅不省空间，反而还翻倍，直到发现可以按条件reindex后，眼前一亮！我按时间条件reindex不就好了嘛~~</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 将 2019-01 月的文档, 全部 reindex 到 knight-log.2019-01 中</span><br><span class="line">curl -X POST "localhost:9200/_reindex" -H 'Content-Type: application/json' -d'</span><br><span class="line">&#123;</span><br><span class="line">  "source": &#123;</span><br><span class="line">    "index": "knight-log",</span><br><span class="line">    "type": "your_doc_type",</span><br><span class="line">    "query": &#123;</span><br><span class="line">      "bool": &#123;</span><br><span class="line">        "filter": &#123;</span><br><span class="line">          "range": &#123;</span><br><span class="line">            "day": &#123;</span><br><span class="line">              "gte": "2019-01-01",</span><br><span class="line">              "lt": "2019-02-01"</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  "dest": &#123;</span><br><span class="line">    "index": "knight-log.2019-01"</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">'</span><br></pre></td></tr></table></figure><blockquote><p>tips1: 在reindex到新index之前，为了加快索引，可以对新index设置，常规的批量索引设置注意项，这里也适用,如：replicas=0，refresh_interval=-1</p></blockquote><blockquote><p>tips2：第一次使用reindex，没有开启slice(相当于多线程)，io和cpu虽然都不高，但很慢，可适当开启，但注意slice不要超过index的shard数，看官方文档，此处不多提！</p></blockquote><blockquote><p>tips3：如果一个月的文档数太多，不放心一次性操作，你可以尝试先按天reindex到新月份index中，这样可以观察cup和io，然后适当调整reindex相关参数后，再把当月余下天数的文档全部reindex到新index中</p></blockquote><blockquote><p>tips4：当进行完一次reindex，恢复 refresh_interval 后，可以对新旧索引同时查询，看文档数是否一致！确保无异常！</p></blockquote><blockquote><p>tips5：手误执行reindex，可以中途取消本次task</p></blockquote><p>将 <em>knight-log</em> 的replicas数从默认的1 变为 0，这样整个index省掉一半大小（非必须，剩余磁盘多可以忽略），然后，对 <em>knight-log</em> 按月份进行reindex，这样反复操作几次，可完成近几月的备份，形如 <em>knight-log.2019-01</em>，<em>knight-log.2018-12</em> 等（不要忘记2月的旧文档哦，同样需要reindex，这样2月的index才会完整），同时因为模板的特性，月份索引会自动加上 <strong>alias-knight-log</strong> 这个别名，一举两得!</p><p>reindex完必要的数据后（如近3月），就可以直接删掉 <em>knight-log</em>！</p><p>若几个月后，磁盘又满了，就可以将最久老月份的index直接物理删除，方便快捷！</p><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>追根究底，这种问题就不应该存在！可能一开始使用es不熟吧，起码按天/月索引是应该具备的基本sense吧，大家要避免这个坑！</p><p>其次，如果单条文档体积较大，可以考虑将数据存入HBase，es中只存docId即可，通过条件搜出对应的docId，然后用docId去HBase取数据，进一步高效利用es，这通过禁用<code>_source</code>字段(保存原文档的json字段)实现。不过，因为es只存倒排索引，所以没了原文档，会缺失部分便捷性，慎重考虑！</p><p>说回来，es不支持将大的索引按时间拆分成小索引，只能在多个api组合中找到最优实践，对应用来说，需要改动索引名后重启，已经是最小化改动，在整个过程中，es保障了正常提供服务，不影响其他业务。<br>经历过上述操作，更加熟练的掌握了es多个相关api，了解查询原理，写入原理，分片分配策略以及查询语句优化等知识点。另: kibana下使用dev tools也非常爽，会弹提示，算是发现的彩蛋，建议多用！</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-背景&quot;&gt;&lt;a href=&quot;#1-背景&quot; class=&quot;headerlink&quot; title=&quot;1. 背景&quot;&gt;&lt;/a&gt;1. 背景&lt;/h2&gt;&lt;p&gt;由于项目初期设计问题，采集到es的业务日志只使用了一个索引(index)，随着线上日志量的增长，es很快飙升到磁盘警戒线，线上找了一圈，很多文章版本都比较老旧，最终直接啃官方文档得出，没有copy别人博客，如果你中途不走神，本文总共15min。version 适用于es 6.0+&lt;/p&gt;
    
    </summary>
    
      <category term="ElasticSearch" scheme="http://yoursite.com/categories/ElasticSearch/"/>
    
    
      <category term="es" scheme="http://yoursite.com/tags/es/"/>
    
      <category term="大索引拆分" scheme="http://yoursite.com/tags/%E5%A4%A7%E7%B4%A2%E5%BC%95%E6%8B%86%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>揭开神秘面纱——深入浅出ThreadLocal</title>
    <link href="http://yoursite.com/2017/12/08/deep-in-threadlocal.html"/>
    <id>http://yoursite.com/2017/12/08/deep-in-threadlocal.html</id>
    <published>2017-12-08T08:02:32.000Z</published>
    <updated>2019-06-22T11:37:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>能够找到这篇文章，说明你已开始学习Java的多线程了，也了解多线程的同步、锁等概念。但，ThreadLocal虽出现在多线程的环境中，对于它的使用，并不涉及到锁和同步的概念。它生于多线程，伴随着多线程的热点，而并不沾染多线程的常见问题，是不是莫名的小清新呢？如果你对它有所了解，听说过内存泄露，如何才能更好的驾驭它呢？带着好奇和疑惑，一起深入ThreadLocal吧！</p><a id="more"></a><h1 id="1-背景"><a href="#1-背景" class="headerlink" title="1.背景"></a>1.背景</h1><p>随便举两个具体的例子：</p><ol><li><p>在一个web项目中，从请求一进来就为之生成一个 <code>uuid</code>，无论系统是否报异常，返回给客户的必须是同一 <code>uuid</code>，可能首先会想到当作方法的参数来传递，这样任何地方可以成功的获取到这个 <code>uuid</code>，但这个 <code>uuid</code> 会在系统中几乎各个方法参数中都会出现，但 <code>uuid</code> 又非主要业务参数，这样势必会与业务耦合性太强。</p></li><li><p>对于很多非线程安全的类而言，如工具类：SimpleDateFormat和JDBC的Connection，它们经常出现在并发环境中，例如Connection，大家刚接触JDBC的时候，都是在方法中完成Connection的 <code>init/commit/close</code>，如多个线程都想连接数据库执行sql，方法有如下：</p><ol><li>对Connection进行同步加锁，协调各个线程操作DB的顺序，没错但很低效。</li><li>每个线程自己创建Connection，会造成频繁的创建和释放连接，线程结束，Connection也就结束。</li></ol></li></ol><h1 id="2-与并发-同步的区别"><a href="#2-与并发-同步的区别" class="headerlink" title="2. 与并发/同步的区别"></a>2. 与并发/同步的区别</h1><p>什么，你突然想到了并发中的同步？先立一个flag，其实他们有本质的区别，同步是协调多个线程对同一个变量的修改，而ThreadLocal则是将这个变量的副本据为线程己有，各个线程操作的是各自的threadlocal变量，各个线程互不影响，自然不会涉及到同步。</p><h1 id="3-易混名词释疑"><a href="#3-易混名词释疑" class="headerlink" title="3. 易混名词释疑"></a>3. 易混名词释疑</h1><p>大家容易搞混<code>Thread/ThreadLocal/ThreadLocalMap</code>三者的关系，其实很简单，如图:</p><p><img src="https://github.com/hulog/hulog.github.io/blob/blog/source/images/post/threadlocal-1.png?raw=true" alt="关系图"></p><p>为了便于大家记住依赖关系，煞费苦心的我编了个故事：从前，有一个雷劈出来一个线程小天(Thread)，有一天，遇到了小乐(threadLocal)，线程小天说：“如果想发挥价值，你必须初始化一个ThreadLocalMap放我这托管！” 小乐调用<code>initialValue()</code>不一会儿就初始化了ThreaLocalMap——小明(ThreadLocal的静态内部类)，然后乐转身给天说，这是小明，小天看着欢喜地说：“明明，我给你一个小名threadLocals吧（将其赋值给当前线程的threadLocals变量），以后呢，你就跟我小天混，只要我还在，你就会有肉吃。你的工作内容也很简单，如果以后小乐调用<code>get()</code>方法获取值的时候，你就将他的 <code>threadLocalHashCode</code> 作为key，在你的Map中找到对应的value。当然 <code>set()</code> 方法也差不多，顶多处理一下hash冲突的问题，不过这是你的内务，我就不干预了。”  当然，小天后面也有遇到其他的ThreadLocal，不过它已经有Map小明了，直接让小明干活就可以了。</p><h1 id="4-源码时间"><a href="#4-源码时间" class="headerlink" title="4. 源码时间"></a>4. 源码时间</h1><p>作为专业的看官，等的就是代码，静下心来，15min后，让你感受到咸鱼翻身，虽然还是咸鱼，哈哈</p><p>来看ThreadLocal这个类，其中包括 <code>get/set/remove</code> 等方法，为了避免码字嫌疑，只贴关键代码(其中加入了笔者<a href="https://hulog.github.io" target="_blank" rel="noopener">Norman</a>的中文注释，帮助理解)，下面逐个介绍：</p><h2 id="4-1-set"><a href="#4-1-set" class="headerlink" title="4.1 set()"></a>4.1 set()</h2><p>代码包含set()方法，同时包括方法体内所调用的其他方法(后同)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码段1</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取当前线程t</span></span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        <span class="comment">// 获取当前线程对应的 ThreadLocalMap，它是ThreadLocal的一个内部类</span></span><br><span class="line">        ThreadLocal.ThreadLocalMap map = getMap(t);</span><br><span class="line">        <span class="comment">// 如果map之前被创建，则直接进map中取值</span></span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">            map.set(<span class="keyword">this</span>, value);</span><br><span class="line">        <span class="comment">// 创建ThreadLocalMap</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            createMap(t, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取线程t的ThreadLocalMap，无则return null</span></span><br><span class="line">    ThreadLocal.<span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建线程t的ThreadLocalMap，并设定初始值</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建新的ThreadLocalMap，并将其与当前线程进行关联，构造方法往下翻</span></span><br><span class="line">        t.threadLocals = <span class="keyword">new</span> ThreadLocal.ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Construct a new map initially containing (firstKey, firstValue).</span></span><br><span class="line"><span class="comment">         * ThreadLocalMaps are constructed lazily, so we only create</span></span><br><span class="line"><span class="comment">         * one when wse have at least one entry to put in it.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">            <span class="comment">// 初始化table，INITIAL_CAPACITY为16</span></span><br><span class="line">            table = <span class="keyword">new</span> Entry[INITIAL_CAPACITY];</span><br><span class="line">            <span class="comment">// 将threadLocal的threadLocalHashCode除以16取模(下面这种骚操作是因为除数是2^n)，得到桶的下标</span></span><br><span class="line">            <span class="keyword">int</span> i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 将生成的Entry 放置于table对应的桶中</span></span><br><span class="line">            table[i] = <span class="keyword">new</span> Entry(firstKey, firstValue);</span><br><span class="line">            size = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 设置扩容阈值为table length的 2/3(负载因子2/3)</span></span><br><span class="line">            setThreshold(INITIAL_CAPACITY);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setThreshold</span><span class="params">(<span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">            threshold = len * <span class="number">2</span> / <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// We don't use a fast path as with get() because it is at</span></span><br><span class="line">            <span class="comment">// least as common to use set() to create new entries as</span></span><br><span class="line">            <span class="comment">// it is to replace existing ones, in which case, a fast</span></span><br><span class="line">            <span class="comment">// path would fail more often than not.</span></span><br><span class="line"></span><br><span class="line">            Entry[] tab = table;</span><br><span class="line">            <span class="keyword">int</span> len = tab.length;</span><br><span class="line">            <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">                 e != <span class="keyword">null</span>;</span><br><span class="line">                 e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">                ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">                    e.value = value;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    replaceStaleEntry(key, value, i);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            tab[i] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">            <span class="keyword">int</span> sz = ++size;</span><br><span class="line">            <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">                rehash();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> threadLocalHashCode = nextHashCode();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger nextHashCode = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The difference between successively generated hash codes - turns</span></span><br><span class="line"><span class="comment">     * implicit sequential thread-local IDs into near-optimally spread</span></span><br><span class="line"><span class="comment">     * multiplicative hash values for power-of-two-sized tables.</span></span><br><span class="line"><span class="comment">     * 这个数字就不得不提了，以他为步长生成的2^n个数字序列，</span></span><br><span class="line"><span class="comment">     * 除以2^n取模后，得到的模居然可以逐个均匀的落在2^n个桶中，</span></span><br><span class="line"><span class="comment">     * 与传统步长(+1)的不同在于，逐个均匀分布(而非连续分布)可以减小碰撞的几率，</span></span><br><span class="line"><span class="comment">     * (可以拿着这个数应用在其他类似场景中)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_INCREMENT = <span class="number">0x61c88647</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextHashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 从0开始递增</span></span><br><span class="line">        <span class="keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码段2</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">    <span class="comment">/* ThreadLocal values pertaining to this thread. This map is maintained</span></span><br><span class="line"><span class="comment">     * by the ThreadLocal class. */</span></span><br><span class="line">    ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整体流程可以看出，当调用<code>set(T value)</code>方法时，会先取出本线程的ThreadLocalMap，对于Map：</p><ul><li>如果不为空，则以ThreadLocal实例为key， 将value存储在此Map中</li><li>如果为空，就创建一个Map，并将其赋值给此线程的成员变量threadLocals</li></ul><p>对于ThreadLocalMap是由谁来维护，其定义的代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码段3</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * The entries in this hash map extend WeakReference, using</span></span><br><span class="line"><span class="comment">         * its main ref field as the key (which is always a</span></span><br><span class="line"><span class="comment">         * ThreadLocal object).  Note that null keys (i.e. entry.get()</span></span><br><span class="line"><span class="comment">         * == null) mean that the key is no longer referenced, so the</span></span><br><span class="line"><span class="comment">         * entry can be expunged from table.  Such entries are referred to</span></span><br><span class="line"><span class="comment">         * as "stale entries" in the code that follows.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&gt; </span>&#123;</span><br><span class="line">            <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">            Object value;</span><br><span class="line"></span><br><span class="line">            Entry(ThreadLocal k, Object v) &#123;</span><br><span class="line">                <span class="keyword">super</span>(k);</span><br><span class="line">                value = v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结合代码段2，可以看出，ThreadLocalMap其实是定义在ThreadLocal中的静态内部类，然后由Thread类来维护，依附于Thread的生命周期。读过HashMap源码的童鞋知道Entry是什么东东，这个Entry 继承了 WeakReference类，其实就Entry的key继承了它，从构造函数就可以看出，顺带简单回顾下java 的引用：</p><ul><li>强引用：不受GC影响，即时OOM也不回收；eg. Person p = new Person(“Norman”)</li><li>软引用：只会在内存不足时，由GC回收；</li><li>弱引用：不论内存是否够用，一旦GC，则回收，不过GC的线程优先级，不一定很快的发现；</li><li>虚引用：形同虚设，与前三不同，它必须配合WeakReferenceQueue，跟踪对象被垃圾回收的活动</li></ul><p>那么，为什么要用到弱引用呢？官方文档如是说：</p><blockquote><p>To help deal with very large and long-lived usages, the hash table entries use WeakReferences for keys. However, since reference queues are not used, stale entries are guaranteed to be removed only when the table starts running out of space.</p><p><a href="https://hulog.github.io" target="_blank" rel="noopener">Norman</a>译：为了应对非常大的和长寿命的对象使用，哈希表 <code>Entry</code> 使用 <code>WeakReferences</code> 作为键。但是，由于没有使用引用队列(Reference类中的队列)， 因此只有当表快耗尽空间时， 才保证将陈旧 <code>Entry</code> 删除。</p></blockquote><p>如下场景很好的解释了这样设计的好处(感谢<a href="http://blog.xiaohansong.com/2016/08/06/ThreadLocal-memory-leak" target="_blank" rel="noopener">xiaohansong</a>)：</p><p><strong>强引用:</strong> 当对象A中引用ThreadLocal的对象B，A被回收，则B变为垃圾，但线程对Map是强引用，Map对B是 <strong>强</strong> 引用，只要线程存活，则B始终不会被回收。</p><p><strong>弱引用:</strong> 当对象A中引用ThreadLocal的对象B，A被回收，则B变为垃圾，由于线程对Map是强引用，Map对B是 <strong>弱</strong> 引用，即使没有手动删除，在下一个GC周期，B也会被回收掉。而Map中的value会在调用set/get/remove方法后断掉强引用，等待GC后续回收(见 <strong>4.4 内存泄露</strong>)。</p><h2 id="4-2-get"><a href="#4-2-get" class="headerlink" title="4.2 get()"></a>4.2 get()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the value in the current thread's copy of this</span></span><br><span class="line"><span class="comment">     * thread-local variable.  If the variable has no value for the</span></span><br><span class="line"><span class="comment">     * current thread, it is first initialized to the value returned</span></span><br><span class="line"><span class="comment">     * by an invocation of the &#123;<span class="doctag">@link</span> #initialValue&#125; method.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the current thread's value of this thread-local</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1.获取当前线程t</span></span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        <span class="comment">// 2.获取当前线程对应的 ThreadLocalMap， 它是ThreadLocal的一个内部类</span></span><br><span class="line">        ThreadLocal.ThreadLocalMap map = getMap(t);</span><br><span class="line">        <span class="comment">// 3.如果map之前被创建，则直接进map中取值</span></span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 3.1 以当前ThreadLocal实例作为key，在map中获取对应的Entry</span></span><br><span class="line">            ThreadLocal.ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                T result = (T)e.value;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4.如果map之前未被创建，或创建后未得到该ThreadLocal实例的Entry</span></span><br><span class="line">        <span class="comment">//   则调用此方法进行初始化，而后返回结果</span></span><br><span class="line">        <span class="keyword">return</span> setInitialValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> Entry <span class="title">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">            Entry e = table[i];</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == key)</span><br><span class="line">                <span class="comment">// 如果在该桶中取到，直接返回</span></span><br><span class="line">                <span class="keyword">return</span> e;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">// 如果不在，则按规则寻找</span></span><br><span class="line">                <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> Entry <span class="title">getEntryAfterMiss</span><span class="params">(ThreadLocal&lt;?&gt; key, <span class="keyword">int</span> i, Entry e)</span> </span>&#123;</span><br><span class="line">            Entry[] tab = table;</span><br><span class="line">            <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">                <span class="keyword">if</span> (k == key)</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">                <span class="keyword">if</span> (k == <span class="keyword">null</span>)</span><br><span class="line">                    expungeStaleEntry(i);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    i = nextIndex(i, len);</span><br><span class="line">                e = tab[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果，当前线程没有threadLocal值，则默认调用initialValue()方法，其中的取值可以看到，ThreadLocalMap中处理Hash冲突的方法是线性探测法，顺带回顾下数据结构中，<strong>Hash冲突的解决办法：</strong></p><ol><li>开放地址法<ul><li>线性探测 (ThreadLocalMap)</li><li>二次探测</li><li>再哈希</li></ul></li><li>再哈希法</li><li>链地址法 (HashMap)</li><li>建立一个公共溢出区</li></ol><h2 id="4-3-remove"><a href="#4-3-remove" class="headerlink" title="4.3 remove()"></a>4.3 remove()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class="line">        <span class="keyword">if</span> (m != <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">// 调用ThreadLocalMap的remove方法</span></span><br><span class="line">            m.remove(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">            Entry[] tab = table;</span><br><span class="line">            <span class="keyword">int</span> len = tab.length;</span><br><span class="line">            <span class="comment">// 按hashcode计算出应该在的位置</span></span><br><span class="line">            <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 考虑到hash冲突，按线性探测查找应该在的位置</span></span><br><span class="line">            <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">                 e != <span class="keyword">null</span>;</span><br><span class="line">                 e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">                <span class="comment">// 判断是否是目标Entry</span></span><br><span class="line">                <span class="keyword">if</span> (e.get() == key) &#123;</span><br><span class="line">                    <span class="comment">// 调用Reference中的clear()方法，Clears this reference object.</span></span><br><span class="line">                    e.clear();</span><br><span class="line">                    <span class="comment">// 将该位置的Entry清除掉后，对table重新整理</span></span><br><span class="line">                    expungeStaleEntry(i);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">expungeStaleEntry</span><span class="params">(<span class="keyword">int</span> staleSlot)</span> </span>&#123;</span><br><span class="line">            Entry[] tab = table;</span><br><span class="line">            <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// expunge entry at staleSlot</span></span><br><span class="line">            <span class="comment">// 先将value引用置空</span></span><br><span class="line">            tab[staleSlot].value = <span class="keyword">null</span>;</span><br><span class="line">            tab[staleSlot] = <span class="keyword">null</span>;</span><br><span class="line">            size--;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Rehash until we encounter null</span></span><br><span class="line">            <span class="comment">// 因为后续连续的元素可能是之前hash冲突引起的，</span></span><br><span class="line">            <span class="comment">// 所以，对table后续连续的元素，进行重新hash</span></span><br><span class="line">            Entry e;</span><br><span class="line">            <span class="keyword">int</span> i;</span><br><span class="line">            <span class="keyword">for</span> (i = nextIndex(staleSlot, len);</span><br><span class="line">                 (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">                 i = nextIndex(i, len)) &#123;</span><br><span class="line">                ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">                <span class="comment">// 如果key为空，顺便清除它</span></span><br><span class="line">                <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    e.value = <span class="keyword">null</span>;</span><br><span class="line">                    tab[i] = <span class="keyword">null</span>;</span><br><span class="line">                    size--;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">int</span> h = k.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">                    <span class="comment">// 如果一个元素按照hashcode运算后，</span></span><br><span class="line">                    <span class="comment">// 实际位置不在应该在的位置，则对其重新hash</span></span><br><span class="line">                    <span class="keyword">if</span> (h != i) &#123;</span><br><span class="line">                        tab[i] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// Unlike Knuth 6.4 Algorithm R, we must scan until</span></span><br><span class="line">                        <span class="comment">// null because multiple entries could have been stale.</span></span><br><span class="line">                        <span class="keyword">while</span> (tab[h] != <span class="keyword">null</span>)</span><br><span class="line">                            h = nextIndex(h, len);</span><br><span class="line">                        tab[h] = e;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-4-内存泄露"><a href="#4-4-内存泄露" class="headerlink" title="4.4 内存泄露"></a>4.4 内存泄露</h2><p>从源码中看，无论是get()，set()还是remove()操作，都会包含对ThreadLocalMap 中key为null的Entry清除，那么泄露会出现在什么地方呢？仔细来看各部分依赖图：</p><p><img src="https://github.com/hulog/hulog.github.io/blob/blog/source/images/post/threadlocal-2.png?raw=true" alt="内部关联"></p><p>ThreadLocal可手动置为null，也可以由GC置null(因为弱引用)，但这只是针对key，对于value，当前Entry的value被Entry引用，而Entry被当前Map引用，而Map则被当前线程实例Thread引用，如果当前线程不退出，则value是不会被GC，造成内存泄露。</p><p>更加准确的说，是发生在 ：<strong>当Map中的key(ThreadLocal)为null后到线程结束</strong> 这期间。当遇到线程池，线程会被重复利用，如果使用 <code>set</code> 后不再使用 <code>get/set/remove</code>，这个强应用会一直存在，造成内存泄露。(PS:当value是大对象时尤为严重)</p><p>那补救措施有哪些呢？</p><ol><li>首先，jdk本身get/set/remove操作会清除key为null的Entry，但属于被动清除，不调用此方法，依然会内存泄露</li><li>其次，当用完threadLocal后，应该主动调用remove方法，主动断掉value到thread的引用链</li></ol><h1 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h1><p>使用ThreadLocal有一些建议：</p><ol><li><p>使用static修饰，使之属于类而不是实例，因为它持有的对象，生效范围一般在用户会话/web请求周期期间。</p><blockquote><p>One web request =&gt; one Persistence session.<br>Not one web request =&gt; one persistence session per object.</p></blockquote></li><li><p>如上文提到，使用结束后调用remove()方法进行清除，避免造成内存泄露。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;能够找到这篇文章，说明你已开始学习Java的多线程了，也了解多线程的同步、锁等概念。但，ThreadLocal虽出现在多线程的环境中，对于它的使用，并不涉及到锁和同步的概念。它生于多线程，伴随着多线程的热点，而并不沾染多线程的常见问题，是不是莫名的小清新呢？如果你对它有所了解，听说过内存泄露，如何才能更好的驾驭它呢？带着好奇和疑惑，一起深入ThreadLocal吧！&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
      <category term="threadlocal" scheme="http://yoursite.com/categories/java/threadlocal/"/>
    
      <category term="多线程" scheme="http://yoursite.com/categories/java/threadlocal/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="threadlocal" scheme="http://yoursite.com/tags/threadlocal/"/>
    
  </entry>
  
  <entry>
    <title>Netty入门第五章——协议栈开发纪要</title>
    <link href="http://yoursite.com/2017/11/01/netty-5.html"/>
    <id>http://yoursite.com/2017/11/01/netty-5.html</id>
    <published>2017-11-01T12:25:40.000Z</published>
    <updated>2019-06-22T11:37:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>Netty的HTTP协议栈开发的客户端和服务端具有Netty的天然优势——异步事件驱动。所以以此开发的HTTP协议栈程序也是异步非阻塞的。本章节介绍如何利用Netty提供的基础完成HTTP协议栈的开发。</p><h2 id="1-Netty-XML-协议栈开发"><a href="#1-Netty-XML-协议栈开发" class="headerlink" title="1. Netty+XML 协议栈开发"></a>1. Netty+XML 协议栈开发</h2><blockquote><p>HTTP仅仅是承载数据交换的通道，是载体而不是Web容器，没有必要上Tomcat等重量型容器。</p></blockquote><h2 id="2-WebSocket开发"><a href="#2-WebSocket开发" class="headerlink" title="2. WebSocket开发"></a>2. WebSocket开发</h2><blockquote><p>对于HTTP协议，开销较大，服务器只有收到请求才会应答，不适合做低延迟应用。Websocket将网络套接字引入客户端和服务端。浏览器和服务器之间可以通过套接字建立持久的连接。双方都可以互发数据给对方。</p></blockquote><a id="more"></a><h3 id="2-1-HTTP协议的弊端："><a href="#2-1-HTTP协议的弊端：" class="headerlink" title="2.1. HTTP协议的弊端："></a>2.1. HTTP协议的弊端：</h3><ol><li>HTTP半双工，两端不能同事传输数据</li><li>HTTP消息冗长繁琐，包括消息头、消息体、换行符等，通常，基于文本传输方式，要比其他二进制通信   协议繁琐和冗长。</li><li>针对服务器推送的黑客攻击，如长轮询。</li></ol><p>目前，很多网站为了实现<strong>消息推送</strong>，基本上都是采用长轮询(例如每秒1次HTTP Request)，header冗长，占用带宽和服务器的资源。因此HTML5定义了WebSocket协议，更好的节省了服务器资源和带宽实现实时通信。<br>新的长轮询技术是Comet，使用AJAX，可达到双向通信，但依然需要发送请求，切普遍采用了长连接，也会消耗带宽和资源。</p><h3 id="2-2-WebSocket特点："><a href="#2-2-WebSocket特点：" class="headerlink" title="2.2. WebSocket特点："></a>2.2. WebSocket特点：</h3><ol><li>浏览器与服务器只需做<strong>一个握手操作</strong>(与TCP握手不在同一层次，TCP握手后连接建立，WebSocket握手是指在TCP建立后告诉服务器这个一个WebSocket握手信息)，然后形成快速通道，WebSocket基于TCP的全双工通讯，相比HTTP的半双工，性能得到较大的提升。</li><li>对代理和防火墙透明</li><li>无Header、Cookie和身份认证</li><li>无安全开销</li><li>通过”ping/pong”帧保持链路激活</li><li>服务器主动推送到客户端，无需客户端的长轮询</li></ol><h3 id="2-3-WebSocket连接的建立和关闭"><a href="#2-3-WebSocket连接的建立和关闭" class="headerlink" title="2.3. WebSocket连接的建立和关闭"></a>2.3. WebSocket连接的建立和关闭</h3><p>建立：需要客户端或者浏览器发出握手请求，请求消息为HTTP请求，其中包含了附加的头信息，如<code>Upgrade: websocket</code>和<code>Connection: Upgrade</code>等。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">GET ws://echo.websocket.org/?encoding=text HTTP/1.1</span><br><span class="line">Host: echo.websocket.org</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Pragma: no-cache</span><br><span class="line">Cache-Control: no-cache</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Origin: http://websocket.org</span><br><span class="line">Sec-WebSocket-Version: 13</span><br><span class="line">User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/54.0.2840.90 Safari/537.36</span><br><span class="line">Accept-Encoding: gzip, deflate, sdch</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,de;q=0.6</span><br><span class="line">Cookie: _ga=GA1.2.2145434661.1502418351; _gid=GA1.2.1865172317.1502418351; _gat=1</span><br><span class="line">Sec-WebSocket-Key: VDY/9d/0RyXxpbW6YRd++Q==</span><br><span class="line">Sec-WebSocket-Extensions: permessage-deflate; client_max_window_bits</span><br></pre></td></tr></table></figure></p><p>服务器解析头信息并做出应答，包含附加字段如：<code>Connection: Upgrade</code>和<code>Upgrade: websocket</code>等<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 101 Web Socket Protocol Handshake</span><br><span class="line">Access-Control-Allow-Credentials: true</span><br><span class="line">Access-Control-Allow-Headers: content-type</span><br><span class="line">Access-Control-Allow-Headers: authorization</span><br><span class="line">Access-Control-Allow-Headers: x-websocket-extensions</span><br><span class="line">Access-Control-Allow-Headers: x-websocket-version</span><br><span class="line">Access-Control-Allow-Headers: x-websocket-protocol</span><br><span class="line">Access-Control-Allow-Origin: http://websocket.org</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Date: Fri, 11 Aug 2017 02:41:01 GMT</span><br><span class="line">Sec-WebSocket-Accept: 0xphShwDb6MpA6oZYZsYpiuJNhk=</span><br><span class="line">Server: Kaazing Gateway</span><br><span class="line">Upgrade: websocket</span><br></pre></td></tr></table></figure></p><p>连接建立成功。</p><p>关闭：<br>上述连接持续到某一端主动关闭连接。<br>底层的TCP连接应该首先由服务器关闭，异常情况下，可以由客户端发起TCP Close。</p><h3 id="3-私有协议栈开发"><a href="#3-私有协议栈开发" class="headerlink" title="3. 私有协议栈开发"></a>3. 私有协议栈开发</h3><blockquote><p>广义上，通信协议可分为公有和私有协议。私有协议具有更好的灵活性，往往会在公司和组织内部使用，按需定制。绝大多数协议都是基于TCP/IP，所以利用Netty的NIO TCP协议栈可以非常方便进行定制开发。</p></blockquote><p>大型系统往往会被拆分成多个模块，各个模块可能需要实现跨节点通信，在传统的JAVA应用中，通常使用一下4种方式进行跨节点通信：</p><ol><li>RMI远程服务调用</li><li>Java的Socket+Java序列化方式</li><li>利用开源RPC框架，如Facebook的Thrift、Apache的Avro</li><li>利用标准的公有协议，如HTTP+XML、RESTful+JSON、Webservice</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Netty的HTTP协议栈开发的客户端和服务端具有Netty的天然优势——异步事件驱动。所以以此开发的HTTP协议栈程序也是异步非阻塞的。本章节介绍如何利用Netty提供的基础完成HTTP协议栈的开发。&lt;/p&gt;
&lt;h2 id=&quot;1-Netty-XML-协议栈开发&quot;&gt;&lt;a href=&quot;#1-Netty-XML-协议栈开发&quot; class=&quot;headerlink&quot; title=&quot;1. Netty+XML 协议栈开发&quot;&gt;&lt;/a&gt;1. Netty+XML 协议栈开发&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;HTTP仅仅是承载数据交换的通道，是载体而不是Web容器，没有必要上Tomcat等重量型容器。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;2-WebSocket开发&quot;&gt;&lt;a href=&quot;#2-WebSocket开发&quot; class=&quot;headerlink&quot; title=&quot;2. WebSocket开发&quot;&gt;&lt;/a&gt;2. WebSocket开发&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;对于HTTP协议，开销较大，服务器只有收到请求才会应答，不适合做低延迟应用。Websocket将网络套接字引入客户端和服务端。浏览器和服务器之间可以通过套接字建立持久的连接。双方都可以互发数据给对方。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="netty" scheme="http://yoursite.com/categories/netty/"/>
    
    
      <category term="netty" scheme="http://yoursite.com/tags/netty/"/>
    
  </entry>
  
  <entry>
    <title>Netty入门第四章——编解码技术</title>
    <link href="http://yoursite.com/2017/11/01/netty-4.html"/>
    <id>http://yoursite.com/2017/11/01/netty-4.html</id>
    <published>2017-11-01T12:16:10.000Z</published>
    <updated>2019-06-22T11:37:16.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>本章主要内容：</p><ul><li>Java序列化的缺点</li><li>业界流行的几种编解码框架介绍</li></ul><blockquote><p>Java的序列化目的：</p><ol><li>网络传输</li><li>对象持久化</li></ol></blockquote><a id="more"></a><p>Java序列化仅仅是编解码技术的一种，目前衍生出多种编解码技术和框架。如Google的Protobuf、Facebook的Thrift和JBoss Marshalling。</p><h2 id="Java序列化缺点"><a href="#Java序列化缺点" class="headerlink" title="Java序列化缺点"></a>Java序列化缺点</h2><ol><li>无法跨语言<br>Java序列化技术是Java语言内部私有协议，其他语言不支持，完全是黑盒。其序列化后的字节数组，其他语言无法反序列化，严重阻碍了其应用。</li><li>序列化后的码流太大</li></ol><h2 id="评判一个编码框架的优劣势"><a href="#评判一个编码框架的优劣势" class="headerlink" title="评判一个编码框架的优劣势"></a>评判一个编码框架的优劣势</h2><ul><li>是否支持跨语言，支持的语言是否丰富</li><li>编码后的码流大小</li><li>编解码的性能</li><li>类库是否小巧，API是否方便</li><li>开发者上手开发难度</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;本章主要内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Java序列化的缺点&lt;/li&gt;
&lt;li&gt;业界流行的几种编解码框架介绍&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;Java的序列化目的：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;网络传输&lt;/li&gt;
&lt;li&gt;对象持久化&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="netty" scheme="http://yoursite.com/categories/netty/"/>
    
    
      <category term="netty" scheme="http://yoursite.com/tags/netty/"/>
    
  </entry>
  
  <entry>
    <title>Netty入门第三章——粘包和拆包</title>
    <link href="http://yoursite.com/2017/11/01/netty-3.html"/>
    <id>http://yoursite.com/2017/11/01/netty-3.html</id>
    <published>2017-11-01T12:13:23.000Z</published>
    <updated>2019-06-22T11:37:16.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TCP粘包产生原因"><a href="#TCP粘包产生原因" class="headerlink" title="TCP粘包产生原因"></a>TCP粘包产生原因</h1><ol><li>应用程序write写入的字节数大小大于套接字发送缓冲区的大小。</li><li>进行MSS大小的TCP分段。</li><li>以太网帧的payload大于MTU进行IP分片。</li></ol><a id="more"></a><h1 id="用于解决TCP粘包问题的编码器"><a href="#用于解决TCP粘包问题的编码器" class="headerlink" title="用于解决TCP粘包问题的编码器"></a>用于解决TCP粘包问题的编码器</h1><table><thead><tr><th style="text-align:left">序号</th><th style="text-align:left">名字</th><th style="text-align:left">作用</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left">LineBasedFrameDecoder</td><td style="text-align:left">基于<strong> <em>行</em> </strong>的解码器</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left">StringDecoder</td><td style="text-align:left">基于<strong> <em>字符串</em> </strong>的解码器</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left">DelimiterBasedFrameDecoder</td><td style="text-align:left">基于<strong> <em>分隔符</em> </strong>作为码流结束标示的消息解码器</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left">FixedLengthFrameDecoder</td><td style="text-align:left">基于<strong> <em>固定长度</em> </strong>解码器</td></tr></tbody></table><ol><li><p><strong>LineBasedFrameDecoder</strong> – 基于<strong> <em>行</em> </strong>的解码器。遍历ByteBuf中的可读字节，判断是否有<code>&quot;\n&quot;</code>或<code>&quot;\r\n&quot;</code>，如有则以此结束位置。可配置单行最大长度，如达到最大长度，仍没有发现换行符，则抛出异常。(见代码片段1)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码片段1</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ChildChanneHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInitiallizer</span>&lt;<span class="title">SocketChannel</span>&gt; </span>&#123;</span><br><span class="line">        <span class="meta">@override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel arg0)</span> <span class="keyword">throws</span> Execption </span>&#123;</span><br><span class="line">            arg0.pipeline().addLast ( <span class="keyword">new</span> LineBasedFrameDecoder(<span class="number">1024</span>));</span><br><span class="line">            arg0.pipeline().addLast ( <span class="keyword">new</span> StringDecoder());</span><br><span class="line">            arg0.pipeline().addLast ( <span class="keyword">new</span> TimeClientHandler());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>StringDecoder</strong> – 基于<strong> <em>字符串</em> </strong>的解码器。将接收到的byte[]转换成字符串。LineBasedFrameDecoder+StringDecoder的组合即为按行切换的文本解码器。</p></li><li><p><strong>DelimiterBasedFrameDecoder</strong> – 基于<strong> <em>分隔符</em> </strong>作为码流结束标示的消息解码器。(见代码片段2)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码片段2</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ChildChanneHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInitiallizer</span>&lt;<span class="title">SocketChannel</span>&gt; </span>&#123;</span><br><span class="line">        <span class="meta">@override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel arg0)</span> <span class="keyword">throws</span> Execption </span>&#123;</span><br><span class="line">            ByteBuf delimiter = Unpooled.copiedBuffer(<span class="string">"$_"</span>.getBytes()))</span><br><span class="line">            arg0.pipeline().addLast ( <span class="keyword">new</span> DelimiterBasedFrameDecoder(<span class="number">1024</span>,delimiter));</span><br><span class="line">            <span class="comment">// arg0.pipeline().addLast ( new LineBasedFrameDecoder(1024));</span></span><br><span class="line">            arg0.pipeline().addLast ( <span class="keyword">new</span> StringDecoder());</span><br><span class="line">            arg0.pipeline().addLast ( <span class="keyword">new</span> TimeClientHandler());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>FixedLengthFrameDecoder</strong> – <strong> <em>固定长度</em> </strong>解码器.(见代码片段3)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码片段3</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ChildChanneHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInitiallizer</span>&lt;<span class="title">SocketChannel</span>&gt; </span>&#123;</span><br><span class="line">        <span class="meta">@override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel arg0)</span> <span class="keyword">throws</span> Execption </span>&#123;</span><br><span class="line">            ByteBuf delimiter = Unpooled.copiedBuffer(<span class="string">"$_"</span>.getBytes()))</span><br><span class="line">            <span class="comment">// arg0.pipeline().addLast ( new DelimiterBasedFrameDecoder(1024,delimiter));</span></span><br><span class="line">            <span class="comment">// arg0.pipeline().addLast ( new LineBasedFrameDecoder(1024));</span></span><br><span class="line">            arg0.pipeline().addLast ( <span class="keyword">new</span> FixedLengthFrameDecoder(<span class="number">20</span>));</span><br><span class="line">            arg0.pipeline().addLast ( <span class="keyword">new</span> StringDecoder());</span><br><span class="line">            arg0.pipeline().addLast ( <span class="keyword">new</span> TimeClientHandler());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;TCP粘包产生原因&quot;&gt;&lt;a href=&quot;#TCP粘包产生原因&quot; class=&quot;headerlink&quot; title=&quot;TCP粘包产生原因&quot;&gt;&lt;/a&gt;TCP粘包产生原因&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;应用程序write写入的字节数大小大于套接字发送缓冲区的大小。&lt;/li&gt;
&lt;li&gt;进行MSS大小的TCP分段。&lt;/li&gt;
&lt;li&gt;以太网帧的payload大于MTU进行IP分片。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="netty" scheme="http://yoursite.com/categories/netty/"/>
    
    
      <category term="netty" scheme="http://yoursite.com/tags/netty/"/>
    
  </entry>
  
  <entry>
    <title>Netty入门第二章——NIO介绍</title>
    <link href="http://yoursite.com/2017/11/01/netty-2.html"/>
    <id>http://yoursite.com/2017/11/01/netty-2.html</id>
    <published>2017-11-01T12:06:59.000Z</published>
    <updated>2019-06-22T11:37:16.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-同步阻塞BIO"><a href="#1-同步阻塞BIO" class="headerlink" title="1. 同步阻塞BIO"></a>1. 同步阻塞BIO</h1><ol><li><code>serversocket</code>负责绑定IP和Port，<code>socket</code>负责发起连接操作。连接成功后，通过输入/输出流进行<strong>同步阻塞</strong>式通信。</li><li>传统<em>请求-应答</em>模型，Acceptor线程每接受一个请求，创建一个线程处理请求并返回。</li></ol><h1 id="2-伪异步IO"><a href="#2-伪异步IO" class="headerlink" title="2. 伪异步IO"></a>2. 伪异步IO</h1><ol><li>后来考虑到高性能/高并发场景，演进了用<strong>线程池/消息队列</strong>实现1个或多个线程处理N个客户端。但底层通信机制仍是同步阻塞IO，故称作<strong>“伪异步”</strong>。线程池中的线程数量和队列大小可控，因此不会导致资源耗尽和宕机。</li><li>弊端：JDK的API文档中，对于InputStream和OutputStream中的read(byte[] b)和write(byte[] b)操作，都是同步阻塞的，亦即一直阻塞直到发生如下事件：<ol><li>有数据可读。</li><li>读到数据末尾。</li><li>发生空指针或IO异常。</li></ol></li></ol><p>如果大量连接上来，前端只有一个Acceptor线程接入请求，那么，之前的请求在线程池中的队列（阻塞队列实现）中排队，队列满，入队操作阻塞，新请求将被拒绝。破解这一难题，NIO入场。<br><a id="more"></a></p><h1 id="3-NIO编程"><a href="#3-NIO编程" class="headerlink" title="3. NIO编程"></a>3. NIO编程</h1><blockquote><p>官方<code>New IO</code>,更多人接受<code>Non-block IO</code>.与Socket和ServerSocket类似，NIO提供了SocketChannel和ServerSocketChannel套接字通道实现，且支持<strong>阻塞</strong>和<strong>非阻塞</strong>模式。</p></blockquote><h2 id="3-1-缓冲区Buffer"><a href="#3-1-缓冲区Buffer" class="headerlink" title="3.1. 缓冲区Buffer"></a>3.1. 缓冲区Buffer</h2><p>在NIO中，所有的数据操作都是面对缓冲区的，从缓冲区读，往缓冲区写。实现原理是<strong>数组</strong>。</p><h2 id="3-2-通道Channel"><a href="#3-2-通道Channel" class="headerlink" title="3.2. 通道Channel"></a>3.2. 通道Channel</h2><p>通道与流的不同，在于通道是双向的，而流是单向的。通道可用于读、写、同时读写。同时支持阻塞和非阻塞模式。</p><h2 id="3-3-多路复用器Selector"><a href="#3-3-多路复用器Selector" class="headerlink" title="3.3. 多路复用器Selector"></a>3.3. 多路复用器Selector</h2><p>多路选择器提供了<strong>选择已经就绪的任务</strong>的能力。Selector会不断轮询注册其上的Channel，如果某个Channel上有新的<em>TCP连接、读、写</em>事件，这个Channel就处于就绪状态，会被Selector轮询出来。JDK使用了epoll()代替了select()实现，没有最大连接句柄数1024/2048的限制，一般1GB内存支持100 000个连接。</p><h1 id="4-AIO-编程"><a href="#4-AIO-编程" class="headerlink" title="4. AIO 编程"></a>4. AIO 编程</h1><p>NIO2.0引入新的异步通道的概念，并提供了异步文件通道和异步套接字通道的实现。是真正的异步非阻塞IO，对应unix的事件驱动IO(AIO)，不需要Selector对其轮询即可实现异步读写。</p><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><h2 id="5-1-不选择原生NIO编程原因"><a href="#5-1-不选择原生NIO编程原因" class="headerlink" title="5.1. 不选择原生NIO编程原因"></a>5.1. 不选择原生NIO编程原因</h2><ol><li>NIO类库和API非常负责，使用麻烦。</li><li>需具备其他技能做铺垫，如Java多线程编程，Reactor模式等。</li><li>可靠性不够，如客户端断连重连，网络闪断，半包读写，失败缓存等。</li><li>JDK的NIO bug，如epoll bug，它会导致Selector空轮询，导致CPU使用率100%。</li></ol><h2 id="5-2-为什么选择Netty"><a href="#5-2-为什么选择Netty" class="headerlink" title="5.2. 为什么选择Netty"></a>5.2. 为什么选择Netty</h2><ol><li>API使用简单，开发门槛低。</li><li>功能强大，预置了多种编解码功能，支持主流协议。</li><li>定制能力强。</li><li>性能高。</li><li>成熟稳定，修复了已发现的所有NIO bug。</li><li>社区活跃，版本迭代周期短。</li><li>经过了大规模的商用考验。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-同步阻塞BIO&quot;&gt;&lt;a href=&quot;#1-同步阻塞BIO&quot; class=&quot;headerlink&quot; title=&quot;1. 同步阻塞BIO&quot;&gt;&lt;/a&gt;1. 同步阻塞BIO&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;code&gt;serversocket&lt;/code&gt;负责绑定IP和Port，&lt;code&gt;socket&lt;/code&gt;负责发起连接操作。连接成功后，通过输入/输出流进行&lt;strong&gt;同步阻塞&lt;/strong&gt;式通信。&lt;/li&gt;
&lt;li&gt;传统&lt;em&gt;请求-应答&lt;/em&gt;模型，Acceptor线程每接受一个请求，创建一个线程处理请求并返回。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;2-伪异步IO&quot;&gt;&lt;a href=&quot;#2-伪异步IO&quot; class=&quot;headerlink&quot; title=&quot;2. 伪异步IO&quot;&gt;&lt;/a&gt;2. 伪异步IO&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;后来考虑到高性能/高并发场景，演进了用&lt;strong&gt;线程池/消息队列&lt;/strong&gt;实现1个或多个线程处理N个客户端。但底层通信机制仍是同步阻塞IO，故称作&lt;strong&gt;“伪异步”&lt;/strong&gt;。线程池中的线程数量和队列大小可控，因此不会导致资源耗尽和宕机。&lt;/li&gt;
&lt;li&gt;弊端：JDK的API文档中，对于InputStream和OutputStream中的read(byte[] b)和write(byte[] b)操作，都是同步阻塞的，亦即一直阻塞直到发生如下事件：&lt;ol&gt;
&lt;li&gt;有数据可读。&lt;/li&gt;
&lt;li&gt;读到数据末尾。&lt;/li&gt;
&lt;li&gt;发生空指针或IO异常。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果大量连接上来，前端只有一个Acceptor线程接入请求，那么，之前的请求在线程池中的队列（阻塞队列实现）中排队，队列满，入队操作阻塞，新请求将被拒绝。破解这一难题，NIO入场。&lt;br&gt;
    
    </summary>
    
      <category term="netty" scheme="http://yoursite.com/categories/netty/"/>
    
    
      <category term="netty" scheme="http://yoursite.com/tags/netty/"/>
    
  </entry>
  
  <entry>
    <title>Nette入门第一章——IO演进</title>
    <link href="http://yoursite.com/2017/11/01/netty-1.html"/>
    <id>http://yoursite.com/2017/11/01/netty-1.html</id>
    <published>2017-11-01T12:01:46.000Z</published>
    <updated>2019-06-22T11:37:16.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-IO-基础"><a href="#1-IO-基础" class="headerlink" title="1.  IO 基础"></a>1.  IO 基础</h1><h2 id="1-1-linux网络IO模型"><a href="#1-1-linux网络IO模型" class="headerlink" title="1.1. linux网络IO模型"></a>1.1. linux网络IO模型</h2><ol><li>阻塞IO模型</li><li>非阻塞IO模型</li><li>IO多路复用模型（NIO）</li><li>信号驱动IO模型</li><li>异步IO模型<a id="more"></a><h2 id="1-2-IO多路复用模型"><a href="#1-2-IO多路复用模型" class="headerlink" title="1.2. IO多路复用模型"></a>1.2. IO多路复用模型</h2></li></ol><p>目前支持IO多路复用的系统调用有<code>select</code>,<code>pselect</code>,<code>poll</code>,<code>epoll</code>。<code>epoll</code>相对于<code>select</code>特点如下：</p><ol><li>支持一个进程打开的<code>socket</code>描述符(FD)不受限制(仅受限与操作系统的最大文件句柄数)。<strong>1</strong>GB内存大约是<strong>10W</strong>个句柄，通过<code>cat /proc/sys/fs/file-max</code> 查看。</li><li>IO效率不会随着FD数目的增加而线性下降。<code>select/poll</code>每次是线性扫描全部集合，因此会线性下降。<code>epoll</code>只处理活跃的socket，但如果所有的socket都活跃， <code>epoll</code>并不比<code>select/poll</code>高很多。</li><li>使用mmap加速内核与用户空间的消息传递。epoll是通过和用户空间mmap同一块内存实现。</li><li><code>epoll</code>的API更加简单。</li></ol><h1 id="2-JAVA-IO演进之路"><a href="#2-JAVA-IO演进之路" class="headerlink" title="2. JAVA IO演进之路"></a>2. JAVA IO演进之路</h1><p>JDK1.4之前–BIO<br>JDK1.4–NIO以JSR-51的身份出现。但是所有文件操作都是同步阻塞调用，不支持文件异步读写操作。<br>JDK1.7–NIO2.0由JSR-203演进而来。具体改进地方如下:</p><ol><li>提供批量获取文件属性的API。</li><li>提供AIO功能，支持基于文件的异步IO和套接字的异步操作。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-IO-基础&quot;&gt;&lt;a href=&quot;#1-IO-基础&quot; class=&quot;headerlink&quot; title=&quot;1.  IO 基础&quot;&gt;&lt;/a&gt;1.  IO 基础&lt;/h1&gt;&lt;h2 id=&quot;1-1-linux网络IO模型&quot;&gt;&lt;a href=&quot;#1-1-linux网络IO模型&quot; class=&quot;headerlink&quot; title=&quot;1.1. linux网络IO模型&quot;&gt;&lt;/a&gt;1.1. linux网络IO模型&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;阻塞IO模型&lt;/li&gt;
&lt;li&gt;非阻塞IO模型&lt;/li&gt;
&lt;li&gt;IO多路复用模型（NIO）&lt;/li&gt;
&lt;li&gt;信号驱动IO模型&lt;/li&gt;
&lt;li&gt;异步IO模型
    
    </summary>
    
      <category term="netty" scheme="http://yoursite.com/categories/netty/"/>
    
    
      <category term="netty" scheme="http://yoursite.com/tags/netty/"/>
    
  </entry>
  
  <entry>
    <title>Java 之 volatile 关键字</title>
    <link href="http://yoursite.com/2017/04/02/volatile.html"/>
    <id>http://yoursite.com/2017/04/02/volatile.html</id>
    <published>2017-04-01T17:32:17.000Z</published>
    <updated>2019-06-22T11:37:16.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>　　要想进军多线程，玩玩高并发，那么你肯定知道线程同步，同步是为了协调多个竞争者对资源的同时访问。对应Java，我们第一反应可能会跳出<code>sychronized</code>关键字，这个关键字能够修饰<code>类</code>，<code>方法</code>，<code>静态方法</code>以及<code>代码块</code>。但是它的性能在高并发下是相当低下的，属于重量级锁。有的业务场景可能不需要这么重量级的锁（比如读多写少，我们如果能够保证获取到的值是最新的就OK），随着对JVM的深入了解，发现CPU不是每次都从内存中取值，各个内核都有自己的缓存，若每个内核中的线程同一时刻对共享变量进行操作，谁的结果才是正确的呢？这样就出现了各个线程的数据同步问题。<br><a id="more"></a></p><h2 id="情景"><a href="#情景" class="headerlink" title="情景"></a>情景</h2><p>　　与synchronized相比，volatile所需的编码较少，运行时的开销也小，但是其功能也只有synchronized的一部分。程序员比较关心的无非是其使用场景，以及如何在代码中使用，本文接下来着重介绍这两方面。<br>　　在目前大多数的处理器架构上，volatile 读操作开销非常低 —— 几乎和非 volatile 读操作一样。而 volatile 写操作的开销要比非 volatile 写操作多很多，因为要保证可见性需要实现内存界定（Memory Fence），即便如此，volatile 的总开销仍然要比锁获取低。<br>　　我们听到的关于volatile最多的特性是<code>可见性</code>，但又不能保证<code>原子性</code>，什么鬼？这两个说的是什么意思？那么，我们用一个例子来表述。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> a;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="title">countA</span><span class="params">()</span></span>&#123;</span><br><span class="line">a++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　我们来分析一下<code>a++</code>这个操作，这个等同于<code>a=a+1</code>，这个里面包含了几个步骤呢？大家先思考一下～</p><hr><p>　　<code>1.</code>首先，我们的CPU是要去取出a的当前值；<code>2.</code>然后执行+1操作；<code>3.</code>最后把结果赋值给左边的a。<br>　　接下来，我们根据这个步骤，解释上面的两个名词。</p><ol><li><strong>取值</strong><br>　　现在的计算机处理器几乎都是多核，不是我们在学校里书本上学的单核，多个核就相当于多个CPU，能够并行地处理任务。假设4 个核，那么就有可能出现，四个线程分别在四个核中同时执行<code>a++</code>。相对于内存io，cpu的执行速度是相当快的，二者的速度不匹配，所以在cpu和内存中间，缓存主要解决这个问题。如图<br><img src="http://ojxisatrc.bkt.clouddn.com/image/multithread/volatile01.jpgafsd" alt="@CPU与内存之间的缓存 | center"><br>图中，L1，L2，L3为三级缓存，越靠近cpu，速度越快，容量也越小。对于多核，情况如下：<br><img src="http://ojxisatrc.bkt.clouddn.com/image/multithread/volatile02.jpgzz" alt="@CPU与内存之间的缓存(多核) | center"><br>　　cpu将会默认从缓存中取a的值，四个处理器中都缓存了a的值，那么谁的值才是最新的/正确的呢？volatile就能保证每个线程取到的值是最新的，即<code>可见性</code>。那么volatile如何保证可见性的呢？<br>　　在x86处理器下<a href="http://www.infoq.com/cn/articles/ftf-java-volatile" target="_blank" rel="noopener">(原文)</a>通过工具获取JIT编译器生成的汇编指令来看看对Volatile进行写操作CPU会做什么事情。</li></ol><table><thead><tr><th style="text-align:right">Java代码</th><th style="text-align:left">instance = new Singleton();//instance是volatile变量</th></tr></thead><tbody><tr><td style="text-align:right">汇编代码</td><td style="text-align:left">0x01a3de1d: movb $0x0,0x1104800(%esi);</td></tr><tr><td style="text-align:right"></td><td style="text-align:left">0x01a3de24: <strong>lock</strong> addl $0x0,(%esp);</td></tr></tbody></table><p>　　有volatile变量修饰的共享变量进行写操作的时候会多第二行汇编代码，通过查IA-32架构软件开发者手册可知，<strong>lock</strong>前缀的指令在多核处理器下会引发了两件事情。<br>　　<code>a</code>. <strong>将当前处理器缓存行的数据会写回到系统内存</strong>。<br>　　<code>b</code>. <strong>这个写回内存的操作会引起在其他CPU里缓存了该内存地址的数据无效</strong>。<br>　　【<code>强烈推荐看完==&gt;</code>】<em>处理器为了提高处理速度，不直接和内存进行通讯，而是先将系统内存的数据读到内部缓存（L1,L2或其他）后再进行操作，但操作完之后不知道何时会写到内存，如果对声明了volatile变量进行写操作，JVM就会向处理器发送一条Lock前缀的指令，将这个变量所在缓存行的数据写回到系统内存。但是就算写回到内存，如果其他处理器缓存的值还是旧的，再执行计算操作就会有问题，所以在多处理器下，为了保证各个处理器的缓存是一致的，就会实现<strong>缓存一致性协议</strong>，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器要对这个数据进行修改操作的时候，会强制重新从系统内存里把数据读到处理器缓存里。</em></p><ol start="2"><li><strong>赋值</strong></li></ol><p>　　从上面，每个线程获取的值都是最新的，cpu拿到数据后，执行<code>+1</code>操作，最后写会内存。问题来了，每个线程如果拿到的值都为最新值<code>5</code>，四个线程同时执行<code>+1</code>后，将值<code>a</code>写回内存，最终结果却成为<code>6</code>，而正确的结果应该是<code>9</code>。所以它不能保证<code>原子性</code>，原子性是指不可中断的一个或一系列操作。</p><h2 id="使用场景及注意事项"><a href="#使用场景及注意事项" class="headerlink" title="使用场景及注意事项"></a>使用场景及注意事项</h2><p>　　您只能在有限的一些情形下使用 volatile 变量替代锁。要使 volatile 变量提供理想的线程安全，必须同时满足下面两个条件<a href="https://www.ibm.com/developerworks/cn/java/j-jtp06197.html" target="_blank" rel="noopener">(原文)</a>：<br>　　<code>a</code>. 对变量的写操作<strong>不依赖于当前值</strong>。<br>　　<code>b</code>. 该变量没有包含在具有其他变量的不变式中。<br><strong>【解析】：</strong>第一个条件的限制使 volatile 变量不能用作线程安全计数器。虽然增量操作（x++）看上去类似一个单独操作，实际上它是一个由 <em><code>读取－修改－写入</code></em> 操作序列组成的组合操作，必须以原子方式执行，而 volatile 不能提供必须的原子特性。实现正确的操作需要使 x 的值在操作期间保持不变，而 volatile 变量无法实现这点。<br>　　volatile 操作不会像锁一样造成阻塞，因此，在能够安全使用 volatile 的情况下，volatile 可以提供一些优于锁的可伸缩特性。如果读操作的次数要远远超过写操作（<code>读多写少</code>），与锁相比，volatile 变量通常能够减少同步的性能开销。<br>　　很多并发性专家事实上往往引导用户远离 volatile 变量，因为使用它们要比使用锁更加容易出错。然而，如果谨慎地遵循一些良好定义的模式，就能够在很多场合内安全地使用 volatile 变量。要始终牢记使用 volatile 的限制 —— 只有在状态真正独立于程序内其他内容时才能使用 volatile —— 这条规则能够避免将这些模式扩展到不安全的用例。<br>　　接下来介绍常见的适用场景。</p><h3 id="1-状态标志"><a href="#1-状态标志" class="headerlink" title="1. 状态标志"></a>1. 状态标志</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> shutdownRequested;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123; shutdownRequested = <span class="keyword">true</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">while</span> (!shutdownRequested) &#123; </span><br><span class="line">        <span class="comment">// do stuff</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　由于 volatile 简化了编码，并且状态标志并不依赖于程序内任何其他状态，因此此处非常适合使用 volatile。</p><h3 id="2-一次性安全发布（one-time-safe-publication）"><a href="#2-一次性安全发布（one-time-safe-publication）" class="headerlink" title="2. 一次性安全发布（one-time safe publication）"></a>2. 一次性安全发布（one-time safe publication）</h3><p>　　在缺乏同步的情况下，可能会遇到某个对象引用的更新值（由另一个线程写入）和该对象状态的旧值同时存在。（这就是造成著名的双重检查锁定（double-checked-locking）问题的根源，其中对象引用在没有同步的情况下进行读操作，产生的问题是您可能会看到一个更新的引用，但是仍然会通过该引用看到不完全构造的对象）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BackgroundFloobleLoader</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> Flooble theFlooble;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initInBackground</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// do lots of stuff</span></span><br><span class="line">        theFlooble = <span class="keyword">new</span> Flooble();  <span class="comment">// this is the only write to theFlooble</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        //此操作包含了（伪代码）：</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        //memory = allocate();   //1：分配对象的内存空间</span></span><br><span class="line"><span class="comment">//ctorInstance(memory);  //2：初始化对象</span></span><br><span class="line"><span class="comment">//instance = memory;     //3：设置instance指向刚分配的内存地址</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">//上面三行伪代码中的2和3之间，可能会被重排序(在一些JIT编译器上，这种重排序是真实发生的)</span></span><br><span class="line"><span class="comment">//2和3之间重排序之后的执行时序如下</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">//memory = allocate();   //1：分配对象的内存空间</span></span><br><span class="line"><span class="comment">//instance = memory;     //3：设置instance指向刚分配的内存地址</span></span><br><span class="line"><span class="comment">//注意，此时对象还没有被初始化！</span></span><br><span class="line"><span class="comment">//ctorInstance(memory);  //2：初始化对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SomeOtherClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123; </span><br><span class="line">            <span class="comment">// do some stuff...</span></span><br><span class="line">            <span class="comment">// use the Flooble, but only if it is ready</span></span><br><span class="line">            <span class="keyword">if</span> (floobleLoader.theFlooble != <span class="keyword">null</span>) </span><br><span class="line">                doSomething(floobleLoader.theFlooble);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　如果 theFlooble 引用不是 volatile 类型，doWork() 中的代码在解除对 theFlooble 的引用时，将会得到一个不完全构造的 Flooble。亦即出现重排序后，虽然拿到了地址值，但是对象还没有初始化结束，如果此时调用该对象，将会出现错误。关于 double-checked locking，强烈推荐<a href="http://www.infoq.com/cn/articles/double-checked-locking-with-delay-initialization" target="_blank" rel="noopener">《双重检查锁定与延迟初始化》</a>。<br>　　与锁相比，Volatile 变量是一种非常简单但同时又非常脆弱的同步机制，它在某些情况下将提供优于锁的性能和伸缩性。如果严格遵循 volatile 的使用条件 —— 即变量真正独立于其他变量和自己以前的值 —— 在某些情况下可以使用 volatile 代替 synchronized 来简化代码。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;　　要想进军多线程，玩玩高并发，那么你肯定知道线程同步，同步是为了协调多个竞争者对资源的同时访问。对应Java，我们第一反应可能会跳出&lt;code&gt;sychronized&lt;/code&gt;关键字，这个关键字能够修饰&lt;code&gt;类&lt;/code&gt;，&lt;code&gt;方法&lt;/code&gt;，&lt;code&gt;静态方法&lt;/code&gt;以及&lt;code&gt;代码块&lt;/code&gt;。但是它的性能在高并发下是相当低下的，属于重量级锁。有的业务场景可能不需要这么重量级的锁（比如读多写少，我们如果能够保证获取到的值是最新的就OK），随着对JVM的深入了解，发现CPU不是每次都从内存中取值，各个内核都有自己的缓存，若每个内核中的线程同一时刻对共享变量进行操作，谁的结果才是正确的呢？这样就出现了各个线程的数据同步问题。&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
      <category term="multithread" scheme="http://yoursite.com/categories/java/multithread/"/>
    
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="锁" scheme="http://yoursite.com/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>服务器基于ThreadPool接收文件</title>
    <link href="http://yoursite.com/2017/02/09/Recieve-File-Via-Threadpool.html"/>
    <id>http://yoursite.com/2017/02/09/Recieve-File-Via-Threadpool.html</id>
    <published>2017-02-09T15:44:40.000Z</published>
    <updated>2019-06-22T11:37:16.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>上篇文章(<a href="http://hulong.me/2017/01/19/Java-ThreadPool.html" target="_blank" rel="noopener">一文带你进入Java之ThreadPool</a>)基本上介绍了Java中的线程池的类型，以及如何按照业务不同自定义线程池。那么问题来了，池建好了，如何让它运行起来呢？本文主要围绕这一主题——让线程池跑起来，进行测试！<br><a id="more"></a></p><h2 id="测试内容"><a href="#测试内容" class="headerlink" title="测试内容"></a>测试内容</h2><p><strong>思路</strong>：模拟多个客户端向服务器发送文件，服务器端一旦监听到请求，立即抛给线程池进行处理，工作线程接受客户端数据，将文件落地。</p><p><em>tips:</em> 只是一个简单的c/s模式，主要测试线程池性能。</p><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol><li>开启服务器进行监听</li><li>用多个线程模拟多个客户端，向服务器发送消息</li><li>服务器监听到请求，立即交给线程池处理</li><li>线程池分配线程接受任务</li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>先说明各个文件作用</p><ol><li><code>TestServerMain.java</code> 用于开启服务器，并开始监听请求</li><li><code>TestClientMain.java</code> 用于开启客户端，并开始发送文件</li><li><code>Client.java</code> 发送文件的实现类</li><li><code>Server.java</code> 服务器初始化和监听实现类</li><li><code>ServerFileHandler.java</code> 服务器端存储文件实现类</li></ol><h4 id="TestServerMain-java"><a href="#TestServerMain-java" class="headerlink" title="TestServerMain.java"></a><code>TestServerMain.java</code></h4><p>开启服务器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.norman.threadpool;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> norman</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestServerMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试主方法.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 运行服务器</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Server.start();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">                    ex.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="TestClientMain-java"><a href="#TestClientMain-java" class="headerlink" title="TestClientMain.java"></a><code>TestClientMain.java</code></h4><p>开启客户端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.norman.threadpool;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 开启客户端</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> norman</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClientMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模拟客户端数量.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> N_THREADS = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 开启N_THREADS个客户端.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException 中断异常.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//文件路径</span></span><br><span class="line">        <span class="keyword">final</span> String pathToFile = <span class="string">"/home/norman/wps-office_8.1.0.3724-b1p2_i386.deb"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N_THREADS; i++) &#123;</span><br><span class="line">                    <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                            Client.send(<span class="keyword">new</span> File(pathToFile));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;).start();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Client-java"><a href="#Client-java" class="headerlink" title="Client.java"></a><code>Client.java</code></h4><p>客户端发送文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.norman.threadpool;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 客户端实体类.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> norman</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送文件.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> file 要进行传输的文件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(File file)</span> </span>&#123;</span><br><span class="line">        String  defaultServerIp = <span class="string">"192.168.199.101"</span>;</span><br><span class="line">        <span class="keyword">int</span>  defaultServerPort = <span class="number">12345</span>;</span><br><span class="line">        send(defaultServerIp, defaultServerPort, file);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 开始发送文件.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ip   ip address</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> port port</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> file 文件对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(String ip, <span class="keyword">int</span> port, File file)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!file.exists()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"文件不存在"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"文件&gt;&gt;&gt;&gt;"</span></span><br><span class="line">                + file.getName()</span><br><span class="line">                + <span class="string">",正在上传......"</span>);</span><br><span class="line">        Socket socket = <span class="keyword">null</span>;</span><br><span class="line">        BufferedReader in = <span class="keyword">null</span>;</span><br><span class="line">        OutputStream out = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            socket = <span class="keyword">new</span> Socket(ip, port);</span><br><span class="line">            in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(socket.getInputStream()));</span><br><span class="line">            out = socket.getOutputStream();</span><br><span class="line">            FileInputStream fis = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">int</span> len;</span><br><span class="line">            <span class="keyword">while</span> ((len = fis.read(buf)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                out.write(buf, <span class="number">0</span>, len);</span><br><span class="line">                out.flush();</span><br><span class="line">            &#125;</span><br><span class="line">            fis.close();</span><br><span class="line">            socket.shutdownOutput();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//接受服务器传回的消息</span></span><br><span class="line">            String temp;</span><br><span class="line">            <span class="keyword">long</span> reply = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((temp = in.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    reply = Long.parseLong(temp);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"数字解析出错"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"客户端收到服务器响应: "</span></span><br><span class="line">                            + temp</span><br><span class="line">                            + <span class="string">" ,文件上传成功率: "</span></span><br><span class="line">                            + reply / file.length() / <span class="number">1.0</span> * <span class="number">100</span></span><br><span class="line">                            + <span class="string">" % "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Server-java"><a href="#Server-java" class="headerlink" title="Server.java"></a><code>Server.java</code></h4><p>服务器接受请求，具体处理交给ServerFileHandler去处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.norman.threadpool;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * BIO服务端源码__伪异步I/O</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> norman</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line">    <span class="comment">//默认监听的端口号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> DEFAULT_PORT = <span class="number">12345</span>;</span><br><span class="line">    <span class="comment">//单例的ServerSocket</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ServerSocket serverSocket;</span><br><span class="line">    <span class="comment">//线程池 懒汉式的单例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">32</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据传入参数设置监听端口，如果没有参数调用以下方法并使用默认值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//使用默认值</span></span><br><span class="line">        start(DEFAULT_PORT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个方法不会被大量并发访问，不太需要考虑效率，直接进行方法同步就行了</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span>  <span class="keyword">void</span> <span class="title">start</span><span class="params">(<span class="keyword">int</span> port)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (serverSocket != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//通过构造函数创建ServerSocket</span></span><br><span class="line">            <span class="comment">//如果端口合法且空闲，服务端就监听成功</span></span><br><span class="line">            serverSocket = <span class="keyword">new</span> ServerSocket(port);</span><br><span class="line">            System.out.println(<span class="string">"服务器已启动，端口号："</span> + port);</span><br><span class="line">            Socket socket;</span><br><span class="line">            <span class="comment">//通过无线循环监听客户端连接</span></span><br><span class="line">            <span class="comment">//如果没有客户端接入，将阻塞在accept操作上。</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                socket = serverSocket.accept();</span><br><span class="line">                <span class="comment">//当有新的客户端接入时，会执行下面的代码</span></span><br><span class="line">                <span class="comment">//然后创建一个新的线程处理这条Socket链路</span></span><br><span class="line">                System.out.println(<span class="string">"服务器已接收到第 "</span> + ++count + <span class="string">" 个任务......"</span>);</span><br><span class="line">                executorService.execute(<span class="keyword">new</span> ServerFileHandler(socket, count));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//一些必要的清理工作</span></span><br><span class="line">            <span class="keyword">if</span> (serverSocket != <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"服务器已关闭。"</span>);</span><br><span class="line">                serverSocket.close();</span><br><span class="line">                serverSocket = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ServerFileHandler-java"><a href="#ServerFileHandler-java" class="headerlink" title="ServerFileHandler.java"></a><code>ServerFileHandler.java</code></h4><p>服务器端处理客户端发来的数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.norman.threadpool;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerFileHandler</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">private</span> Socket socket;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ServerFileHandler</span><span class="params">(Socket socket, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.count = count;</span><br><span class="line">        <span class="keyword">this</span>.socket = socket;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        InputStream in = <span class="keyword">null</span>;</span><br><span class="line">        PrintWriter out = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            in = socket.getInputStream();</span><br><span class="line">            out = <span class="keyword">new</span> PrintWriter(socket.getOutputStream(), <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">            File dstFile = <span class="keyword">new</span> File(<span class="string">"/home/norman/temp/No."</span> + count + <span class="string">".deb"</span>);</span><br><span class="line">            FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(dstFile);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4096</span>];</span><br><span class="line">            <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">long</span> size = <span class="number">0L</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">            <span class="keyword">while</span> ((len = in.read(buf)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                fos.write(buf, <span class="number">0</span>, len);</span><br><span class="line">                fos.flush();</span><br><span class="line">                size += len;</span><br><span class="line">            &#125;</span><br><span class="line">            out.println(size);</span><br><span class="line">            out.flush();</span><br><span class="line">            <span class="keyword">long</span> time = System.currentTimeMillis() - start;</span><br><span class="line">            <span class="keyword">double</span> vv = size / <span class="number">1024.0</span> / <span class="number">1024</span> / (time / <span class="number">1000.0</span>);</span><br><span class="line">            System.out.println(<span class="string">"服务器已接受第 "</span></span><br><span class="line">                    + count</span><br><span class="line">                    + <span class="string">" 个任务对应的文件,\t"</span></span><br><span class="line">                    + <span class="string">"耗时 "</span></span><br><span class="line">                    + time / <span class="number">1000.0</span></span><br><span class="line">                    + <span class="string">"s,\t 上传速率 "</span></span><br><span class="line">                    + vv</span><br><span class="line">                    + <span class="string">" MB/s"</span>);</span><br><span class="line">            fos.close();</span><br><span class="line">            in.close();</span><br><span class="line">            out.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端发送文件后截图：</p><p><img src="http://ojxisatrc.bkt.clouddn.com/image/threadpool/client.png" alt="客户端"></p><p>服务器端收到文件后截图：<br><img src="http://ojxisatrc.bkt.clouddn.com/image/threadpool/server.png" alt="服务器端"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;上篇文章(&lt;a href=&quot;http://hulong.me/2017/01/19/Java-ThreadPool.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;一文带你进入Java之ThreadPool&lt;/a&gt;)基本上介绍了Java中的线程池的类型，以及如何按照业务不同自定义线程池。那么问题来了，池建好了，如何让它运行起来呢？本文主要围绕这一主题——让线程池跑起来，进行测试！&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
      <category term="ThreadPool" scheme="http://yoursite.com/categories/java/ThreadPool/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="线程池" scheme="http://yoursite.com/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
      <category term="IO" scheme="http://yoursite.com/tags/IO/"/>
    
      <category term="Socket" scheme="http://yoursite.com/tags/Socket/"/>
    
      <category term="ThreadPool" scheme="http://yoursite.com/tags/ThreadPool/"/>
    
  </entry>
  
  <entry>
    <title>一文带你进入Java之ThreadPool</title>
    <link href="http://yoursite.com/2017/01/19/Java-ThreadPool.html"/>
    <id>http://yoursite.com/2017/01/19/Java-ThreadPool.html</id>
    <published>2017-01-19T15:10:21.000Z</published>
    <updated>2019-06-22T11:37:16.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h2><blockquote><p>　　在计算机程序设计中，线程池是一个在计算机程序中实现并发执行的软件设计模式。一个线程池保持多个线程等待任务分配给并发执行的监督程序。通过维护一个线程池的模型，提高性能，例如，对于执行时间较短的任务，避免了由于频繁创建和销毁线程造成的系统消耗。——<a href="https://en.wikipedia.org/wiki/Thread_pool" target="_blank" rel="noopener">维基百科</a></p></blockquote><a id="more"></a><p>　　<strong>个人理解：</strong>线程池就相当于一个处理任务的线程工厂，里面有很多工人（线程），当任务来了的时候，可以让工人立即开始工作（线程执行），当任务处理完了，则可以让工人休息（sleep）。所以，处理任务时，我们不用花时间单独去外面请工人（线程的创建），完事后不用辞退工人（线程的销毁），在任务量比较庞大的时候，能够显著的提高系统的处理能力。</p><p>　　其作用总结如下：</p><ol><li>控制和管理线程；</li><li>显著减少CPU闲置时间；</li><li>提升吞吐能力。</li></ol><p><em><code>tips</code>:本讲的线程池主要是针对Java自带的java.util.concurrent包</em>。</p><h2 id="2-使用场景"><a href="#2-使用场景" class="headerlink" title="2.使用场景"></a>2.使用场景</h2><p>那什么时候可以考虑上线程池呢？首先，对于线程，可以粗略的分为三个周期：</p><table><thead><tr><th style="text-align:center">T<sub>1</sub></th><th style="text-align:center">T<sub>2</sub></th><th style="text-align:center">T<sub>3</sub></th></tr></thead><tbody><tr><td style="text-align:center">线程创建</td><td style="text-align:center">线程执行</td><td style="text-align:center">线程销毁</td></tr></tbody></table><p>当<strong>T<sub>1</sub>+T<sub>3</sub>&gt;&gt;T<sub>2</sub></strong>时，可以考虑上线程池。对于如何估算各个周期的执行时间，可以粗略分析是否是CPU密集型任务，如果不是，举个极端例子：求1+1=?，那么线程执行周期T<sub>2</sub>就明显很短，创建和销毁时间远大于执行时间。此时就可以考虑上线程池了。</p><p>那么，很多童鞋会有个疑惑，线程池与<code>new Thread()</code>有什么区别呢？线程池的好处在于：</p><ol><li>重用存在的线程，减少对象创建、消亡的开销，性能佳。</li><li>可有效控制最大并发线程数，提高系统资源的使用率，同时避免过多资源竞争，避免堵塞。</li><li>提供定时执行、定期执行、单线程、并发数控制等功能。</li></ol><p>相反，<code>new Thread()</code>方法只是单纯的创建线程，注重单个线程本身。当启动多个线程时，需循环调用<code>new Thread()</code>方法，耗费大量时间在创建和销毁线程上。</p><h2 id="3-重要组成部分（类）"><a href="#3-重要组成部分（类）" class="headerlink" title="3. 重要组成部分（类）"></a>3. 重要组成部分（类）</h2><p>Java中线程池的顶级接口是<code>Executor</code>，里面<code>只</code>提供了一个方法<code>void execute(Runnable command);</code>,可以看出来它只是提供了一个线程执行的工具类，所以我们更认同地将其子类<code>ExecutorService</code>视为线程池真正的接口。</p><p><img src="http://upload-images.jianshu.io/upload_images/2803944-443efc5a7ea3facb.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="线程池相关类"></p><p>具体介绍下面继续，废话不多说，赶紧的先建个线程池出来溜溜～～～<br>创建线程池的方法有很多种，我们快马加鞭，来个最省事儿的，傻瓜式的创建线程池，不得不先提出<code>Executors</code>类（注意带<code>s</code>），本类为创建线程池的工具类（了解Java集合的童鞋，可以类比<code>Collections</code>类与<code>Collection</code>接口）。</p><h3 id="3-1-Executors类"><a href="#3-1-Executors类" class="headerlink" title="3.1 Executors类"></a>3.1 Executors类</h3><p>该类提供了创建线程池的方法，比较常用的如下：</p><ol><li><code>newSingleThreadExecutor();</code></li><li><code>newFixedThreadPool(int nThreads);</code></li><li><code>newCachedThreadPool();</code></li><li><code>newScheduledThreadPool(int corePoolSize);</code></li></ol><p>以上方法都会返回一个线程池，只是各自的功能不一样，下面分别介绍各自的实现和使用场景。</p><h4 id="3-1-1-newSingleThreadExecutor"><a href="#3-1-1-newSingleThreadExecutor" class="headerlink" title="3.1.1 newSingleThreadExecutor();"></a>3.1.1 newSingleThreadExecutor();</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">          (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                    <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建一个单线程的线程池，池中保持单个线程串行执行任务，如果线程因异常结束，则会创建一个新的线程来替代它，可以保证所有任务的执行顺序按照任务的提交顺序执行。</p><h4 id="3-1-2-newFixedThreadPool-int-nThreads"><a href="#3-1-2-newFixedThreadPool-int-nThreads" class="headerlink" title="3.1.2 newFixedThreadPool(int nThreads)"></a>3.1.2 newFixedThreadPool(int nThreads)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建一个固定大小可重用线程的线程池，任何时候，顶多有nThreads个线程处于活跃状态执行任务。当nThreads个线程满负荷运转时，新增的任务会加到无界队列里等候，直到有空闲线程来处理。当线程因异常退出后，会创建一个新线程来替代。在某个线程被显式地关闭之前，池中的线程将一直存在。</p><h4 id="3-1-3-newCachedThreadPool"><a href="#3-1-3-newCachedThreadPool" class="headerlink" title="3.1.3 newCachedThreadPool();"></a>3.1.3 newCachedThreadPool();</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建一个可根据需要创建新线程的线程池，优先重用已创建的可用的线程，该线程池可以显著的提高程序的性能。当没有可用的线程时，则会在池中创建新的线程。当线程没有被使用超过60s，则会从池中remove掉，最低数量为0。因此，长时间保持空闲的线程池不会消耗任何资源。但是，当出现新任务时，又要创建一新的工作线程，又要一定的系统开销。并且，在使用CachedThreadPool时，一定要注意控制任务的数量，否则，由于大量线程同时运行，很有会造成系统瘫痪。可以使用<code>ThreadPoolExecutor</code>构造方法（<strong>后文会重点讲到</strong>）创建具有类似属性但细节不同（例如超时参数）的线程池。</p><h4 id="3-1-4-newScheduledThreadPool-int-corePoolSize"><a href="#3-1-4-newScheduledThreadPool-int-corePoolSize" class="headerlink" title="3.1.4 newScheduledThreadPool(int corePoolSize);"></a>3.1.4 newScheduledThreadPool(int corePoolSize);</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduledThreadPoolExecutor</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">ThreadPoolExecutor</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">ScheduledExecutorService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ScheduledThreadPoolExecutor类的构造方法，其余方法和变量略</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, TimeUnit.NANOSECONDS,</span><br><span class="line">              <span class="keyword">new</span> DelayedWorkQueue());</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>创建一个能在指定时间后或周期性地执行任务的线程池，池中会保持corePoolSize个线程，即使处于空闲状态。</p><h3 id="3-2-ThreadPoolExecutor类"><a href="#3-2-ThreadPoolExecutor类" class="headerlink" title="3.2 ThreadPoolExecutor类"></a>3.2 ThreadPoolExecutor类</h3><p>可以看出，上面四种线程池都基本上是基于<code>ThreadPoolExecutor</code>和<code>ScheduledThreadPoolExecutor</code>来实现的。在此，我们主要讲解前者，了解其构造函数的各个参数的实际意义。</p><p>一切没有源码的解释都是耍流氓。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="keyword">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数名</th><th>作用</th></tr></thead><tbody><tr><td><code>corePoolSize</code></td><td>线程池维护的核心线程数量。当超过这个范围的时候，就需要将新的Runnable放入到等待队列workQueue中了</td></tr><tr><td><code>maximumPoolSize</code></td><td>线程池维护的最大线程数量。如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。如果使用了无界的<code>workQueue</code>任务队列这个参数就没效果</td></tr><tr><td><code>keepAliveTime</code></td><td>线程池中超过<code>corePoolSize</code>的线程的存活时间</td></tr><tr><td><code>unit</code></td><td><code>keepAliveTime</code>的时间单位</td></tr><tr><td><code>workQueue</code></td><td>线程池所使用的缓冲队列。用于保存等待执行的任务，常见的队列有<code>ArrayBlockingQueue</code>，<code>LinkedBlockingQueue</code>和<code>SynchronousQueue</code>(<em>区别见<strong>注1</strong></em>)</td></tr><tr><td><code>threadFactory</code></td><td>创建新线程所使用的线程工厂。可以通过线程工厂给每个创建出来的线程设置自定义名字，主要实现newThread方法即可</td></tr><tr><td><code>handler</code></td><td>参数<code>maximumPoolSize</code>达到后丢弃处理的方法，常见的策略有<code>AbortPolicy</code>，<code>CallerRunsPolicy</code>，<code>DiscardOldestPolicy</code>和<code>DiscardPolicy</code>(<em>区别见<strong>注2</strong></em>)。可以根据应用场景需要来实现RejectedExecutionHandler接口的rejectedExecution方法，来实现自定义策略，如记录日志或持久化不能处理的任务</td></tr></tbody></table><ul><li><strong>注1</strong>：<ol><li><code>ArrayBlockingQueue</code>: 基于数组的有界队列。有助于防止资源耗尽，但较难控制大小，需要考虑池大小和队列的大小的折衷，大型池小型队列cpu使用率较高，但是请求量很大时，可能遇到不可接受的调度开销。小型池大型队列会降低cpu使用率，避免频繁的线程切换导致的系统消耗，但处理速率也就下降了。值得注意的是，在生产者放入数据和消费者获取数据，都是共用同一个锁对象，由此也意味着两者无法真正并行运行，这点尤其不同于LinkedBlockingQueue。</li><li><code>LinkedBlockingQueue</code>: 基于链表的“无界”队列。实际上具有<em>类似无限大小</em>的容量(Integer.MAX_VALUE)，也可以在构造函数中指定大小。LinkedBlockingQueue之所以能够高效的处理并发数据，还因为其对于生产者端和消费者端分别采用了独立的锁来控制数据同步，这也意味着在高并发的情况下生产者和消费者可以并行地操作队列中的数据，以此来提高整个队列的并发性能。</li><li><code>SynchronousQueue</code>: 无缓冲的等待队列，类似于无中介的直接交易，其特点是读取交替完成，没有实际容量，它将任务直接提交。对于SynchronousQueue的作用jdk中写的很清楚：此策略可以避免在处理可能具有内部依赖性的请求集时出现锁。举个例子，如果你的任务A<sub>1</sub>，A<sub>2</sub>有内部关联，A<sub>1</sub>需要先运行，那么先提交A<sub>1</sub>，再提交A<sub>2</sub>，当使用SynchronousQueue我们可以保证，A<sub>1</sub>必定先被执行，在A<sub>1</sub>没有被执行前，A<sub>2</sub>不可能添加入queue中。</li></ol></li><li><strong>注2</strong>：<ol><li><code>AbortPolicy</code> : java默认，抛出一个异常：RejectedExecutionException。</li><li><code>CallerRunsPolicy</code> : 如果发现线程池还在运行，就直接运行这个线程的run()方法。</li><li><code>DiscardOldestPolicy</code> : 在线程池的等待队列中，将队首任务抛弃，使用当前任务来替换。</li><li><code>DiscardPolicy</code> : 什么也不做。</li></ol></li></ul><p>这一块不清楚的可以参看<a href="http://segmentfault.com/a/1190000000394999?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="noopener">Java线程池架构(一)原理和源码解析</a></p><p><em>tips：下面就是我看完某篇博文收到启发，举一个经典的例子，大家可以按照这个思路去理解。</em></p><p>把线程池理解成一个医院，在医院成立之初，医生数量为 <strong>0</strong>，当有患者时，没有医生来诊疗患者，医院会去招聘新的医生，一旦这些医生忙不过来时，继续招聘，直到达到<code>corePoolSize</code>数量，停止招聘。此时的<code>corePoolSize</code>个医生为正式员工，即使没有患者，也不会辞退他们（<em>销毁线程</em>）。</p><p>医生达到<code>corePoolSize</code>后，当有新患者来就诊，医生忙不过来时，直接让他们在候诊区（<code>workQueue</code>）取号等候，当医生看完上一个病人时，会去候诊区叫下一个号进去，如果没有患者，则可以休息。</p><p>当患者数量急剧上升，候诊区座位数不够了，这时，医院会再去招聘临时工医生，这些临时工医生会让没有座位的患者立即就诊，医院按需求逐个招聘，直到达到<code>maximumPoolSize</code>数量，停止招聘。</p><p>当临时招聘的医生长时间（<code>keepAliveTime</code>）处于空闲状态时，医院就会解雇他们，毕竟要额外付工资啊～</p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p><strong>综上</strong>，文中提到创建线程池的方式有两种:</p><ol><li><p>通过Executors类提供的静态工厂方法，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService es = Executors.newFixedThreadPool(nThreads);</span><br></pre></td></tr></table></figure></li><li><p>通过ThreadPoolExecutor来构造，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService es =</span><br><span class="line">    <span class="keyword">new</span> ThreadPoolExecutor(corePoolSize,maximumPoolSize,</span><br><span class="line">        keepAliveTime,timeUnit,workQueue);</span><br></pre></td></tr></table></figure></li></ol><p>其中，如果没有特殊要求，使用第一种方法可以快速构建出线程池。如果根据业务不同，需要自定义线程池，第二种方法将给你充分的发挥空间。</p><p>下篇博文将会利用线程池基于Socket实现<strong>客户端-&gt;服务器</strong>文件的传输，将会有大量实例代码。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1.简介&quot;&gt;&lt;/a&gt;1.简介&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;　　在计算机程序设计中，线程池是一个在计算机程序中实现并发执行的软件设计模式。一个线程池保持多个线程等待任务分配给并发执行的监督程序。通过维护一个线程池的模型，提高性能，例如，对于执行时间较短的任务，避免了由于频繁创建和销毁线程造成的系统消耗。——&lt;a href=&quot;https://en.wikipedia.org/wiki/Thread_pool&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;维基百科&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="线程池" scheme="http://yoursite.com/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>workbench只导出数据（含insert语句）</title>
    <link href="http://yoursite.com/2016/08/27/workbench-output.html"/>
    <id>http://yoursite.com/2016/08/27/workbench-output.html</id>
    <published>2016-08-27T12:28:28.000Z</published>
    <updated>2019-06-22T11:37:16.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-说明："><a href="#1-说明：" class="headerlink" title="1. 说明："></a>1. 说明：</h1><p><strong>出发点：</strong><br>　　由于特殊原因，我们<strong>只想</strong>导出数据库中的数据（<code>insert into</code>语句格式的），但是在网上找到的资源很少（关于linux），因此特撰此文。<br><a id="more"></a></p><h1 id="2-环境"><a href="#2-环境" class="headerlink" title="2. 环境"></a>2. 环境</h1><ol><li><em>mysql</em></li><li><em>mysql workbench</em></li><li><em>ubuntu (linux)</em></li></ol><h1 id="3-开始"><a href="#3-开始" class="headerlink" title="3. 开始"></a>3. 开始</h1><ol><li>打开<strong>workbench</strong>,连接上数据库后进入主界面；</li><li>在左侧导航栏中，点击<em>MANAGEMENT</em>中的<code>Data Export</code>；</li><li>默认<code>Object Selection</code>页面中，在<code>Select Database Objects to Export</code>栏里勾选你要导出的数据库；</li><li><strong>重头戏</strong><ol><li>点击右上方的<code>Advanced  Options...</code>按钮，进入高级设置界面；</li><li>在<code>Inserts</code>栏中，勾选<code>extended-insert</code>（本表所有数据只用一条<code>insert into</code>语句，如果你想一张表中的每条数据都对应着一个<code>insert into</code>语句，你可以取消勾选本选项，勾选上面的<code>compelete-insert</code>）；</li><li>在<code>SQL</code>栏中，勾选<code>comments</code>和<code>quote-names</code>选项；</li><li>在<code>Tables</code>栏中，<strong>务必</strong>勾选上<code>no-create-info</code>选项；</li><li>点击<strong>右上角</strong>的<code>&lt; Return</code>按钮，回到初始界面；</li></ol></li><li>在<code>Options</code>栏中，点击<code>Export to Self-Contained File</code>，在后面输入导出路径即可；</li><li>点击右下角<code>Start Export</code>按钮，导出成功；</li></ol><h1 id="4-结语"><a href="#4-结语" class="headerlink" title="4. 结语"></a>4. 结语</h1><p>　　本文在实际工程中有应用到，希望能够帮助到大家。ps:同时，这也算是正式进军<em>Markdown</em>的写作行列的<em>milestone</em>。图片暂时没时间加，更新的时候再弄上去吧。^_^</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-说明：&quot;&gt;&lt;a href=&quot;#1-说明：&quot; class=&quot;headerlink&quot; title=&quot;1. 说明：&quot;&gt;&lt;/a&gt;1. 说明：&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;出发点：&lt;/strong&gt;&lt;br&gt;　　由于特殊原因，我们&lt;strong&gt;只想&lt;/strong&gt;导出数据库中的数据（&lt;code&gt;insert into&lt;/code&gt;语句格式的），但是在网上找到的资源很少（关于linux），因此特撰此文。&lt;br&gt;
    
    </summary>
    
      <category term="mysql" scheme="http://yoursite.com/categories/mysql/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
      <category term="workbench" scheme="http://yoursite.com/tags/workbench/"/>
    
      <category term="ubuntu" scheme="http://yoursite.com/tags/ubuntu/"/>
    
      <category term="数据" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE/"/>
    
      <category term="数据库" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
</feed>
